// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: EventCollection.proto

#ifndef PROTOBUF_EventCollection_2eproto__INCLUDED
#define PROTOBUF_EventCollection_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace HEP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_EventCollection_2eproto();
void protobuf_AssignDesc_EventCollection_2eproto();
void protobuf_ShutdownFile_EventCollection_2eproto();

class Jet;
class GenJet;
class GenParticle;
class Electron;
class Electron_GSFTrack;
class Muon;
class MET;
class Vertex;
class BeamSpot;
class Trigger;
class Event;
class GenEvent;
class EventCollection;

enum Jet_JetAlgorithm {
  Jet_JetAlgorithm_Calo_AntiKT_Cone05 = 0,
  Jet_JetAlgorithm_CA08PF = 1,
  Jet_JetAlgorithm_PF2PAT = 2
};
bool Jet_JetAlgorithm_IsValid(int value);
const Jet_JetAlgorithm Jet_JetAlgorithm_JetAlgorithm_MIN = Jet_JetAlgorithm_Calo_AntiKT_Cone05;
const Jet_JetAlgorithm Jet_JetAlgorithm_JetAlgorithm_MAX = Jet_JetAlgorithm_PF2PAT;
const int Jet_JetAlgorithm_JetAlgorithm_ARRAYSIZE = Jet_JetAlgorithm_JetAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Jet_JetAlgorithm_descriptor();
inline const ::std::string& Jet_JetAlgorithm_Name(Jet_JetAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Jet_JetAlgorithm_descriptor(), value);
}
inline bool Jet_JetAlgorithm_Parse(
    const ::std::string& name, Jet_JetAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Jet_JetAlgorithm>(
    Jet_JetAlgorithm_descriptor(), name, value);
}
enum Electron_ElectronAlgorithm {
  Electron_ElectronAlgorithm_Calo = 0,
  Electron_ElectronAlgorithm_ParticleFlow = 1
};
bool Electron_ElectronAlgorithm_IsValid(int value);
const Electron_ElectronAlgorithm Electron_ElectronAlgorithm_ElectronAlgorithm_MIN = Electron_ElectronAlgorithm_Calo;
const Electron_ElectronAlgorithm Electron_ElectronAlgorithm_ElectronAlgorithm_MAX = Electron_ElectronAlgorithm_ParticleFlow;
const int Electron_ElectronAlgorithm_ElectronAlgorithm_ARRAYSIZE = Electron_ElectronAlgorithm_ElectronAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Electron_ElectronAlgorithm_descriptor();
inline const ::std::string& Electron_ElectronAlgorithm_Name(Electron_ElectronAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Electron_ElectronAlgorithm_descriptor(), value);
}
inline bool Electron_ElectronAlgorithm_Parse(
    const ::std::string& name, Electron_ElectronAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Electron_ElectronAlgorithm>(
    Electron_ElectronAlgorithm_descriptor(), name, value);
}
enum Muon_MuonAlgorithm {
  Muon_MuonAlgorithm_Default = 0,
  Muon_MuonAlgorithm_ParticleFlow = 1
};
bool Muon_MuonAlgorithm_IsValid(int value);
const Muon_MuonAlgorithm Muon_MuonAlgorithm_MuonAlgorithm_MIN = Muon_MuonAlgorithm_Default;
const Muon_MuonAlgorithm Muon_MuonAlgorithm_MuonAlgorithm_MAX = Muon_MuonAlgorithm_ParticleFlow;
const int Muon_MuonAlgorithm_MuonAlgorithm_ARRAYSIZE = Muon_MuonAlgorithm_MuonAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Muon_MuonAlgorithm_descriptor();
inline const ::std::string& Muon_MuonAlgorithm_Name(Muon_MuonAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Muon_MuonAlgorithm_descriptor(), value);
}
inline bool Muon_MuonAlgorithm_Parse(
    const ::std::string& name, Muon_MuonAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Muon_MuonAlgorithm>(
    Muon_MuonAlgorithm_descriptor(), name, value);
}
enum MET_METAlgorithm {
  MET_METAlgorithm_Calo = 0,
  MET_METAlgorithm_ParticleFlow = 1
};
bool MET_METAlgorithm_IsValid(int value);
const MET_METAlgorithm MET_METAlgorithm_METAlgorithm_MIN = MET_METAlgorithm_Calo;
const MET_METAlgorithm MET_METAlgorithm_METAlgorithm_MAX = MET_METAlgorithm_ParticleFlow;
const int MET_METAlgorithm_METAlgorithm_ARRAYSIZE = MET_METAlgorithm_METAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* MET_METAlgorithm_descriptor();
inline const ::std::string& MET_METAlgorithm_Name(MET_METAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    MET_METAlgorithm_descriptor(), value);
}
inline bool MET_METAlgorithm_Parse(
    const ::std::string& name, MET_METAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MET_METAlgorithm>(
    MET_METAlgorithm_descriptor(), name, value);
}
// ===================================================================

class Jet : public ::google::protobuf::Message {
 public:
  Jet();
  virtual ~Jet();
  
  Jet(const Jet& from);
  
  inline Jet& operator=(const Jet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Jet& default_instance();
  
  void Swap(Jet* other);
  
  // implements Message ----------------------------------------------
  
  Jet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Jet& from);
  void MergeFrom(const Jet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Jet_JetAlgorithm JetAlgorithm;
  static const JetAlgorithm Calo_AntiKT_Cone05 = Jet_JetAlgorithm_Calo_AntiKT_Cone05;
  static const JetAlgorithm CA08PF = Jet_JetAlgorithm_CA08PF;
  static const JetAlgorithm PF2PAT = Jet_JetAlgorithm_PF2PAT;
  static inline bool JetAlgorithm_IsValid(int value) {
    return Jet_JetAlgorithm_IsValid(value);
  }
  static const JetAlgorithm JetAlgorithm_MIN =
    Jet_JetAlgorithm_JetAlgorithm_MIN;
  static const JetAlgorithm JetAlgorithm_MAX =
    Jet_JetAlgorithm_JetAlgorithm_MAX;
  static const int JetAlgorithm_ARRAYSIZE =
    Jet_JetAlgorithm_JetAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JetAlgorithm_descriptor() {
    return Jet_JetAlgorithm_descriptor();
  }
  static inline const ::std::string& JetAlgorithm_Name(JetAlgorithm value) {
    return Jet_JetAlgorithm_Name(value);
  }
  static inline bool JetAlgorithm_Parse(const ::std::string& name,
      JetAlgorithm* value) {
    return Jet_JetAlgorithm_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional double Energy = 1 [default = 0];
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 1;
  inline double energy() const;
  inline void set_energy(double value);
  
  // optional double Px = 2 [default = 0];
  inline bool has_px() const;
  inline void clear_px();
  static const int kPxFieldNumber = 2;
  inline double px() const;
  inline void set_px(double value);
  
  // optional double Py = 3 [default = 0];
  inline bool has_py() const;
  inline void clear_py();
  static const int kPyFieldNumber = 3;
  inline double py() const;
  inline void set_py(double value);
  
  // optional double Pz = 4 [default = 0];
  inline bool has_pz() const;
  inline void clear_pz();
  static const int kPzFieldNumber = 4;
  inline double pz() const;
  inline void set_pz(double value);
  
  // optional double Charge = 5 [default = 0];
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 5;
  inline double charge() const;
  inline void set_charge(double value);
  
  // optional double Mass = 6 [default = 0];
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 6;
  inline double mass() const;
  inline void set_mass(double value);
  
  // optional .HEP.Jet.JetAlgorithm type = 7 [default = PF2PAT];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::HEP::Jet_JetAlgorithm type() const;
  inline void set_type(::HEP::Jet_JetAlgorithm value);
  
  // optional double Eta = 8 [default = 0];
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 8;
  inline double eta() const;
  inline void set_eta(double value);
  
  // optional double Phi = 9 [default = 0];
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 9;
  inline double phi() const;
  inline void set_phi(double value);
  
  // optional double Pt = 10 [default = 0];
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 10;
  inline double pt() const;
  inline void set_pt(double value);
  
  // optional double PtRaw = 11 [default = 0];
  inline bool has_ptraw() const;
  inline void clear_ptraw();
  static const int kPtRawFieldNumber = 11;
  inline double ptraw() const;
  inline void set_ptraw(double value);
  
  // optional double EnergyRaw = 12 [default = 0];
  inline bool has_energyraw() const;
  inline void clear_energyraw();
  static const int kEnergyRawFieldNumber = 12;
  inline double energyraw() const;
  inline void set_energyraw(double value);
  
  // optional int32 PartonFlavour = 13 [default = 0];
  inline bool has_partonflavour() const;
  inline void clear_partonflavour();
  static const int kPartonFlavourFieldNumber = 13;
  inline ::google::protobuf::int32 partonflavour() const;
  inline void set_partonflavour(::google::protobuf::int32 value);
  
  // optional double JECUnc = 14 [default = 0];
  inline bool has_jecunc() const;
  inline void clear_jecunc();
  static const int kJECUncFieldNumber = 14;
  inline double jecunc() const;
  inline void set_jecunc(double value);
  
  // optional double L2L3ResJEC = 15 [default = 0];
  inline bool has_l2l3resjec() const;
  inline void clear_l2l3resjec();
  static const int kL2L3ResJECFieldNumber = 15;
  inline double l2l3resjec() const;
  inline void set_l2l3resjec(double value);
  
  // optional double L3AbsJEC = 16 [default = 0];
  inline bool has_l3absjec() const;
  inline void clear_l3absjec();
  static const int kL3AbsJECFieldNumber = 16;
  inline double l3absjec() const;
  inline void set_l3absjec(double value);
  
  // optional double L2RelJEC = 17 [default = 0];
  inline bool has_l2reljec() const;
  inline void clear_l2reljec();
  static const int kL2RelJECFieldNumber = 17;
  inline double l2reljec() const;
  inline void set_l2reljec(double value);
  
  // optional double L1OffJEC = 18 [default = 0];
  inline bool has_l1offjec() const;
  inline void clear_l1offjec();
  static const int kL1OffJECFieldNumber = 18;
  inline double l1offjec() const;
  inline void set_l1offjec(double value);
  
  // optional double EMF = 19 [default = 0];
  inline bool has_emf() const;
  inline void clear_emf();
  static const int kEMFFieldNumber = 19;
  inline double emf() const;
  inline void set_emf(double value);
  
  // optional double resEMF = 20 [default = 0];
  inline bool has_resemf() const;
  inline void clear_resemf();
  static const int kResEMFFieldNumber = 20;
  inline double resemf() const;
  inline void set_resemf(double value);
  
  // optional double HADF = 21 [default = 0];
  inline bool has_hadf() const;
  inline void clear_hadf();
  static const int kHADFFieldNumber = 21;
  inline double hadf() const;
  inline void set_hadf(double value);
  
  // optional int32 n90Hits = 22 [default = 0];
  inline bool has_n90hits() const;
  inline void clear_n90hits();
  static const int kN90HitsFieldNumber = 22;
  inline ::google::protobuf::int32 n90hits() const;
  inline void set_n90hits(::google::protobuf::int32 value);
  
  // optional double fHPD = 23 [default = 0];
  inline bool has_fhpd() const;
  inline void clear_fhpd();
  static const int kFHPDFieldNumber = 23;
  inline double fhpd() const;
  inline void set_fhpd(double value);
  
  // optional double fRBX = 24 [default = 0];
  inline bool has_frbx() const;
  inline void clear_frbx();
  static const int kFRBXFieldNumber = 24;
  inline double frbx() const;
  inline void set_frbx(double value);
  
  // optional double SigmaEta = 25 [default = 0];
  inline bool has_sigmaeta() const;
  inline void clear_sigmaeta();
  static const int kSigmaEtaFieldNumber = 25;
  inline double sigmaeta() const;
  inline void set_sigmaeta(double value);
  
  // optional double SigmaPhi = 26 [default = 0];
  inline bool has_sigmaphi() const;
  inline void clear_sigmaphi();
  static const int kSigmaPhiFieldNumber = 26;
  inline double sigmaphi() const;
  inline void set_sigmaphi(double value);
  
  // optional double TrackCountingHighEffBTag = 27 [default = 0];
  inline bool has_trackcountinghigheffbtag() const;
  inline void clear_trackcountinghigheffbtag();
  static const int kTrackCountingHighEffBTagFieldNumber = 27;
  inline double trackcountinghigheffbtag() const;
  inline void set_trackcountinghigheffbtag(double value);
  
  // optional double TrackCountingHighPurBTag = 28 [default = 0];
  inline bool has_trackcountinghighpurbtag() const;
  inline void clear_trackcountinghighpurbtag();
  static const int kTrackCountingHighPurBTagFieldNumber = 28;
  inline double trackcountinghighpurbtag() const;
  inline void set_trackcountinghighpurbtag(double value);
  
  // optional double SimpleSecondaryVertexHighEffBTag = 29 [default = 0];
  inline bool has_simplesecondaryvertexhigheffbtag() const;
  inline void clear_simplesecondaryvertexhigheffbtag();
  static const int kSimpleSecondaryVertexHighEffBTagFieldNumber = 29;
  inline double simplesecondaryvertexhigheffbtag() const;
  inline void set_simplesecondaryvertexhigheffbtag(double value);
  
  // optional double SimpleSecondaryVertexHighPurBTag = 30 [default = 0];
  inline bool has_simplesecondaryvertexhighpurbtag() const;
  inline void clear_simplesecondaryvertexhighpurbtag();
  static const int kSimpleSecondaryVertexHighPurBTagFieldNumber = 30;
  inline double simplesecondaryvertexhighpurbtag() const;
  inline void set_simplesecondaryvertexhighpurbtag(double value);
  
  // optional double JetProbabilityBTag = 31 [default = 0];
  inline bool has_jetprobabilitybtag() const;
  inline void clear_jetprobabilitybtag();
  static const int kJetProbabilityBTagFieldNumber = 31;
  inline double jetprobabilitybtag() const;
  inline void set_jetprobabilitybtag(double value);
  
  // optional double JetBProbabilityBTag = 32 [default = 0];
  inline bool has_jetbprobabilitybtag() const;
  inline void clear_jetbprobabilitybtag();
  static const int kJetBProbabilityBTagFieldNumber = 32;
  inline double jetbprobabilitybtag() const;
  inline void set_jetbprobabilitybtag(double value);
  
  // optional double SoftElectronBJetTag = 33 [default = 0];
  inline bool has_softelectronbjettag() const;
  inline void clear_softelectronbjettag();
  static const int kSoftElectronBJetTagFieldNumber = 33;
  inline double softelectronbjettag() const;
  inline void set_softelectronbjettag(double value);
  
  // optional double SoftMuonBJetTag = 34 [default = 0];
  inline bool has_softmuonbjettag() const;
  inline void clear_softmuonbjettag();
  static const int kSoftMuonBJetTagFieldNumber = 34;
  inline double softmuonbjettag() const;
  inline void set_softmuonbjettag(double value);
  
  // optional double SoftMuonNoIPBJetTag = 35 [default = 0];
  inline bool has_softmuonnoipbjettag() const;
  inline void clear_softmuonnoipbjettag();
  static const int kSoftMuonNoIPBJetTagFieldNumber = 35;
  inline double softmuonnoipbjettag() const;
  inline void set_softmuonnoipbjettag(double value);
  
  // optional double CombinedSVBJetTag = 36 [default = 0];
  inline bool has_combinedsvbjettag() const;
  inline void clear_combinedsvbjettag();
  static const int kCombinedSVBJetTagFieldNumber = 36;
  inline double combinedsvbjettag() const;
  inline void set_combinedsvbjettag(double value);
  
  // optional double CombinedSVMVABJetTag = 37 [default = 0];
  inline bool has_combinedsvmvabjettag() const;
  inline void clear_combinedsvmvabjettag();
  static const int kCombinedSVMVABJetTagFieldNumber = 37;
  inline double combinedsvmvabjettag() const;
  inline void set_combinedsvmvabjettag(double value);
  
  // optional int32 PassLooseID = 38 [default = 0];
  inline bool has_passlooseid() const;
  inline void clear_passlooseid();
  static const int kPassLooseIDFieldNumber = 38;
  inline ::google::protobuf::int32 passlooseid() const;
  inline void set_passlooseid(::google::protobuf::int32 value);
  
  // optional int32 PassTightID = 39 [default = 0];
  inline bool has_passtightid() const;
  inline void clear_passtightid();
  static const int kPassTightIDFieldNumber = 39;
  inline ::google::protobuf::int32 passtightid() const;
  inline void set_passtightid(::google::protobuf::int32 value);
  
  // optional double ChargedEmEnergyFraction = 40 [default = 0];
  inline bool has_chargedemenergyfraction() const;
  inline void clear_chargedemenergyfraction();
  static const int kChargedEmEnergyFractionFieldNumber = 40;
  inline double chargedemenergyfraction() const;
  inline void set_chargedemenergyfraction(double value);
  
  // optional double ChargedHadronEnergyFraction = 41 [default = 0];
  inline bool has_chargedhadronenergyfraction() const;
  inline void clear_chargedhadronenergyfraction();
  static const int kChargedHadronEnergyFractionFieldNumber = 41;
  inline double chargedhadronenergyfraction() const;
  inline void set_chargedhadronenergyfraction(double value);
  
  // optional double ChargedMuEnergyFraction = 42 [default = 0];
  inline bool has_chargedmuenergyfraction() const;
  inline void clear_chargedmuenergyfraction();
  static const int kChargedMuEnergyFractionFieldNumber = 42;
  inline double chargedmuenergyfraction() const;
  inline void set_chargedmuenergyfraction(double value);
  
  // optional double ElectronEnergyFraction = 43 [default = 0];
  inline bool has_electronenergyfraction() const;
  inline void clear_electronenergyfraction();
  static const int kElectronEnergyFractionFieldNumber = 43;
  inline double electronenergyfraction() const;
  inline void set_electronenergyfraction(double value);
  
  // optional double MuonEnergyFraction = 44 [default = 0];
  inline bool has_muonenergyfraction() const;
  inline void clear_muonenergyfraction();
  static const int kMuonEnergyFractionFieldNumber = 44;
  inline double muonenergyfraction() const;
  inline void set_muonenergyfraction(double value);
  
  // optional double NeutralEmEnergyFraction = 45 [default = 0];
  inline bool has_neutralemenergyfraction() const;
  inline void clear_neutralemenergyfraction();
  static const int kNeutralEmEnergyFractionFieldNumber = 45;
  inline double neutralemenergyfraction() const;
  inline void set_neutralemenergyfraction(double value);
  
  // optional double NeutralHadronEnergyFraction = 46 [default = 0];
  inline bool has_neutralhadronenergyfraction() const;
  inline void clear_neutralhadronenergyfraction();
  static const int kNeutralHadronEnergyFractionFieldNumber = 46;
  inline double neutralhadronenergyfraction() const;
  inline void set_neutralhadronenergyfraction(double value);
  
  // optional double PhotonEnergyFraction = 47 [default = 0];
  inline bool has_photonenergyfraction() const;
  inline void clear_photonenergyfraction();
  static const int kPhotonEnergyFractionFieldNumber = 47;
  inline double photonenergyfraction() const;
  inline void set_photonenergyfraction(double value);
  
  // optional int32 ChargedHadronMultiplicity = 48 [default = 0];
  inline bool has_chargedhadronmultiplicity() const;
  inline void clear_chargedhadronmultiplicity();
  static const int kChargedHadronMultiplicityFieldNumber = 48;
  inline ::google::protobuf::int32 chargedhadronmultiplicity() const;
  inline void set_chargedhadronmultiplicity(::google::protobuf::int32 value);
  
  // optional int32 ChargedMultiplicity = 49 [default = 0];
  inline bool has_chargedmultiplicity() const;
  inline void clear_chargedmultiplicity();
  static const int kChargedMultiplicityFieldNumber = 49;
  inline ::google::protobuf::int32 chargedmultiplicity() const;
  inline void set_chargedmultiplicity(::google::protobuf::int32 value);
  
  // optional int32 ElectronMultiplicity = 50 [default = 0];
  inline bool has_electronmultiplicity() const;
  inline void clear_electronmultiplicity();
  static const int kElectronMultiplicityFieldNumber = 50;
  inline ::google::protobuf::int32 electronmultiplicity() const;
  inline void set_electronmultiplicity(::google::protobuf::int32 value);
  
  // optional int32 MuonMultiplicity = 51 [default = 0];
  inline bool has_muonmultiplicity() const;
  inline void clear_muonmultiplicity();
  static const int kMuonMultiplicityFieldNumber = 51;
  inline ::google::protobuf::int32 muonmultiplicity() const;
  inline void set_muonmultiplicity(::google::protobuf::int32 value);
  
  // optional int32 NeutralHadronMultiplicity = 52 [default = 0];
  inline bool has_neutralhadronmultiplicity() const;
  inline void clear_neutralhadronmultiplicity();
  static const int kNeutralHadronMultiplicityFieldNumber = 52;
  inline ::google::protobuf::int32 neutralhadronmultiplicity() const;
  inline void set_neutralhadronmultiplicity(::google::protobuf::int32 value);
  
  // optional int32 NeutralMultiplicity = 53 [default = 0];
  inline bool has_neutralmultiplicity() const;
  inline void clear_neutralmultiplicity();
  static const int kNeutralMultiplicityFieldNumber = 53;
  inline ::google::protobuf::int32 neutralmultiplicity() const;
  inline void set_neutralmultiplicity(::google::protobuf::int32 value);
  
  // optional int32 PhotonMultiplicity = 54 [default = 0];
  inline bool has_photonmultiplicity() const;
  inline void clear_photonmultiplicity();
  static const int kPhotonMultiplicityFieldNumber = 54;
  inline ::google::protobuf::int32 photonmultiplicity() const;
  inline void set_photonmultiplicity(::google::protobuf::int32 value);
  
  // optional int32 NConstituents = 55 [default = 0];
  inline bool has_nconstituents() const;
  inline void clear_nconstituents();
  static const int kNConstituentsFieldNumber = 55;
  inline ::google::protobuf::int32 nconstituents() const;
  inline void set_nconstituents(::google::protobuf::int32 value);
  
  // optional double ChargedEmEnergyFractionRAW = 56 [default = 0];
  inline bool has_chargedemenergyfractionraw() const;
  inline void clear_chargedemenergyfractionraw();
  static const int kChargedEmEnergyFractionRAWFieldNumber = 56;
  inline double chargedemenergyfractionraw() const;
  inline void set_chargedemenergyfractionraw(double value);
  
  // optional double ChargedHadronEnergyFractionRAW = 57 [default = 0];
  inline bool has_chargedhadronenergyfractionraw() const;
  inline void clear_chargedhadronenergyfractionraw();
  static const int kChargedHadronEnergyFractionRAWFieldNumber = 57;
  inline double chargedhadronenergyfractionraw() const;
  inline void set_chargedhadronenergyfractionraw(double value);
  
  // optional double NeutralEmEnergyFractionRAW = 58 [default = 0];
  inline bool has_neutralemenergyfractionraw() const;
  inline void clear_neutralemenergyfractionraw();
  static const int kNeutralEmEnergyFractionRAWFieldNumber = 58;
  inline double neutralemenergyfractionraw() const;
  inline void set_neutralemenergyfractionraw(double value);
  
  // optional double NeutralHadronEnergyFractionRAW = 59 [default = 0];
  inline bool has_neutralhadronenergyfractionraw() const;
  inline void clear_neutralhadronenergyfractionraw();
  static const int kNeutralHadronEnergyFractionRAWFieldNumber = 59;
  inline double neutralhadronenergyfractionraw() const;
  inline void set_neutralhadronenergyfractionraw(double value);
  
  // optional double BestVertexTrackAssociationFactor = 60 [default = 0];
  inline bool has_bestvertextrackassociationfactor() const;
  inline void clear_bestvertextrackassociationfactor();
  static const int kBestVertexTrackAssociationFactorFieldNumber = 60;
  inline double bestvertextrackassociationfactor() const;
  inline void set_bestvertextrackassociationfactor(double value);
  
  // optional double ClosestVertexWeighted3DSeparation = 61 [default = 0];
  inline bool has_closestvertexweighted3dseparation() const;
  inline void clear_closestvertexweighted3dseparation();
  static const int kClosestVertexWeighted3DSeparationFieldNumber = 61;
  inline double closestvertexweighted3dseparation() const;
  inline void set_closestvertexweighted3dseparation(double value);
  
  // optional double ClosestVertexWeightedXYSeparation = 62 [default = 0];
  inline bool has_closestvertexweightedxyseparation() const;
  inline void clear_closestvertexweightedxyseparation();
  static const int kClosestVertexWeightedXYSeparationFieldNumber = 62;
  inline double closestvertexweightedxyseparation() const;
  inline void set_closestvertexweightedxyseparation(double value);
  
  // optional double ClosestVertexWeightedZSeparation = 63 [default = 0];
  inline bool has_closestvertexweightedzseparation() const;
  inline void clear_closestvertexweightedzseparation();
  static const int kClosestVertexWeightedZSeparationFieldNumber = 63;
  inline double closestvertexweightedzseparation() const;
  inline void set_closestvertexweightedzseparation(double value);
  
  // optional int32 BestVertexTrackAssociationIndex = 64 [default = 0];
  inline bool has_bestvertextrackassociationindex() const;
  inline void clear_bestvertextrackassociationindex();
  static const int kBestVertexTrackAssociationIndexFieldNumber = 64;
  inline ::google::protobuf::int32 bestvertextrackassociationindex() const;
  inline void set_bestvertextrackassociationindex(::google::protobuf::int32 value);
  
  // optional int32 ClosestVertex3DIndex = 65 [default = 0];
  inline bool has_closestvertex3dindex() const;
  inline void clear_closestvertex3dindex();
  static const int kClosestVertex3DIndexFieldNumber = 65;
  inline ::google::protobuf::int32 closestvertex3dindex() const;
  inline void set_closestvertex3dindex(::google::protobuf::int32 value);
  
  // optional int32 ClosestVertexXYIndex = 66 [default = 0];
  inline bool has_closestvertexxyindex() const;
  inline void clear_closestvertexxyindex();
  static const int kClosestVertexXYIndexFieldNumber = 66;
  inline ::google::protobuf::int32 closestvertexxyindex() const;
  inline void set_closestvertexxyindex(::google::protobuf::int32 value);
  
  // optional int32 ClosestVertexZIndex = 67 [default = 0];
  inline bool has_closestvertexzindex() const;
  inline void clear_closestvertexzindex();
  static const int kClosestVertexZIndexFieldNumber = 67;
  inline ::google::protobuf::int32 closestvertexzindex() const;
  inline void set_closestvertexzindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:HEP.Jet)
 private:
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_px();
  inline void clear_has_px();
  inline void set_has_py();
  inline void clear_has_py();
  inline void set_has_pz();
  inline void clear_has_pz();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_pt();
  inline void clear_has_pt();
  inline void set_has_ptraw();
  inline void clear_has_ptraw();
  inline void set_has_energyraw();
  inline void clear_has_energyraw();
  inline void set_has_partonflavour();
  inline void clear_has_partonflavour();
  inline void set_has_jecunc();
  inline void clear_has_jecunc();
  inline void set_has_l2l3resjec();
  inline void clear_has_l2l3resjec();
  inline void set_has_l3absjec();
  inline void clear_has_l3absjec();
  inline void set_has_l2reljec();
  inline void clear_has_l2reljec();
  inline void set_has_l1offjec();
  inline void clear_has_l1offjec();
  inline void set_has_emf();
  inline void clear_has_emf();
  inline void set_has_resemf();
  inline void clear_has_resemf();
  inline void set_has_hadf();
  inline void clear_has_hadf();
  inline void set_has_n90hits();
  inline void clear_has_n90hits();
  inline void set_has_fhpd();
  inline void clear_has_fhpd();
  inline void set_has_frbx();
  inline void clear_has_frbx();
  inline void set_has_sigmaeta();
  inline void clear_has_sigmaeta();
  inline void set_has_sigmaphi();
  inline void clear_has_sigmaphi();
  inline void set_has_trackcountinghigheffbtag();
  inline void clear_has_trackcountinghigheffbtag();
  inline void set_has_trackcountinghighpurbtag();
  inline void clear_has_trackcountinghighpurbtag();
  inline void set_has_simplesecondaryvertexhigheffbtag();
  inline void clear_has_simplesecondaryvertexhigheffbtag();
  inline void set_has_simplesecondaryvertexhighpurbtag();
  inline void clear_has_simplesecondaryvertexhighpurbtag();
  inline void set_has_jetprobabilitybtag();
  inline void clear_has_jetprobabilitybtag();
  inline void set_has_jetbprobabilitybtag();
  inline void clear_has_jetbprobabilitybtag();
  inline void set_has_softelectronbjettag();
  inline void clear_has_softelectronbjettag();
  inline void set_has_softmuonbjettag();
  inline void clear_has_softmuonbjettag();
  inline void set_has_softmuonnoipbjettag();
  inline void clear_has_softmuonnoipbjettag();
  inline void set_has_combinedsvbjettag();
  inline void clear_has_combinedsvbjettag();
  inline void set_has_combinedsvmvabjettag();
  inline void clear_has_combinedsvmvabjettag();
  inline void set_has_passlooseid();
  inline void clear_has_passlooseid();
  inline void set_has_passtightid();
  inline void clear_has_passtightid();
  inline void set_has_chargedemenergyfraction();
  inline void clear_has_chargedemenergyfraction();
  inline void set_has_chargedhadronenergyfraction();
  inline void clear_has_chargedhadronenergyfraction();
  inline void set_has_chargedmuenergyfraction();
  inline void clear_has_chargedmuenergyfraction();
  inline void set_has_electronenergyfraction();
  inline void clear_has_electronenergyfraction();
  inline void set_has_muonenergyfraction();
  inline void clear_has_muonenergyfraction();
  inline void set_has_neutralemenergyfraction();
  inline void clear_has_neutralemenergyfraction();
  inline void set_has_neutralhadronenergyfraction();
  inline void clear_has_neutralhadronenergyfraction();
  inline void set_has_photonenergyfraction();
  inline void clear_has_photonenergyfraction();
  inline void set_has_chargedhadronmultiplicity();
  inline void clear_has_chargedhadronmultiplicity();
  inline void set_has_chargedmultiplicity();
  inline void clear_has_chargedmultiplicity();
  inline void set_has_electronmultiplicity();
  inline void clear_has_electronmultiplicity();
  inline void set_has_muonmultiplicity();
  inline void clear_has_muonmultiplicity();
  inline void set_has_neutralhadronmultiplicity();
  inline void clear_has_neutralhadronmultiplicity();
  inline void set_has_neutralmultiplicity();
  inline void clear_has_neutralmultiplicity();
  inline void set_has_photonmultiplicity();
  inline void clear_has_photonmultiplicity();
  inline void set_has_nconstituents();
  inline void clear_has_nconstituents();
  inline void set_has_chargedemenergyfractionraw();
  inline void clear_has_chargedemenergyfractionraw();
  inline void set_has_chargedhadronenergyfractionraw();
  inline void clear_has_chargedhadronenergyfractionraw();
  inline void set_has_neutralemenergyfractionraw();
  inline void clear_has_neutralemenergyfractionraw();
  inline void set_has_neutralhadronenergyfractionraw();
  inline void clear_has_neutralhadronenergyfractionraw();
  inline void set_has_bestvertextrackassociationfactor();
  inline void clear_has_bestvertextrackassociationfactor();
  inline void set_has_closestvertexweighted3dseparation();
  inline void clear_has_closestvertexweighted3dseparation();
  inline void set_has_closestvertexweightedxyseparation();
  inline void clear_has_closestvertexweightedxyseparation();
  inline void set_has_closestvertexweightedzseparation();
  inline void clear_has_closestvertexweightedzseparation();
  inline void set_has_bestvertextrackassociationindex();
  inline void clear_has_bestvertextrackassociationindex();
  inline void set_has_closestvertex3dindex();
  inline void clear_has_closestvertex3dindex();
  inline void set_has_closestvertexxyindex();
  inline void clear_has_closestvertexxyindex();
  inline void set_has_closestvertexzindex();
  inline void clear_has_closestvertexzindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double energy_;
  double px_;
  double py_;
  double pz_;
  double charge_;
  double mass_;
  double eta_;
  double phi_;
  double pt_;
  int type_;
  ::google::protobuf::int32 partonflavour_;
  double ptraw_;
  double energyraw_;
  double jecunc_;
  double l2l3resjec_;
  double l3absjec_;
  double l2reljec_;
  double l1offjec_;
  double emf_;
  double resemf_;
  double hadf_;
  double fhpd_;
  double frbx_;
  double sigmaeta_;
  double sigmaphi_;
  double trackcountinghigheffbtag_;
  double trackcountinghighpurbtag_;
  double simplesecondaryvertexhigheffbtag_;
  double simplesecondaryvertexhighpurbtag_;
  ::google::protobuf::int32 n90hits_;
  ::google::protobuf::int32 passlooseid_;
  double jetprobabilitybtag_;
  double jetbprobabilitybtag_;
  double softelectronbjettag_;
  double softmuonbjettag_;
  double softmuonnoipbjettag_;
  double combinedsvbjettag_;
  double combinedsvmvabjettag_;
  double chargedemenergyfraction_;
  double chargedhadronenergyfraction_;
  double chargedmuenergyfraction_;
  double electronenergyfraction_;
  ::google::protobuf::int32 passtightid_;
  ::google::protobuf::int32 chargedhadronmultiplicity_;
  double muonenergyfraction_;
  double neutralemenergyfraction_;
  double neutralhadronenergyfraction_;
  double photonenergyfraction_;
  ::google::protobuf::int32 chargedmultiplicity_;
  ::google::protobuf::int32 electronmultiplicity_;
  ::google::protobuf::int32 muonmultiplicity_;
  ::google::protobuf::int32 neutralhadronmultiplicity_;
  ::google::protobuf::int32 neutralmultiplicity_;
  ::google::protobuf::int32 photonmultiplicity_;
  double chargedemenergyfractionraw_;
  double chargedhadronenergyfractionraw_;
  double neutralemenergyfractionraw_;
  double neutralhadronenergyfractionraw_;
  ::google::protobuf::int32 nconstituents_;
  ::google::protobuf::int32 bestvertextrackassociationindex_;
  double bestvertextrackassociationfactor_;
  double closestvertexweighted3dseparation_;
  double closestvertexweightedxyseparation_;
  double closestvertexweightedzseparation_;
  ::google::protobuf::int32 closestvertex3dindex_;
  ::google::protobuf::int32 closestvertexxyindex_;
  ::google::protobuf::int32 closestvertexzindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(67 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Jet* default_instance_;
};
// -------------------------------------------------------------------

class GenJet : public ::google::protobuf::Message {
 public:
  GenJet();
  virtual ~GenJet();
  
  GenJet(const GenJet& from);
  
  inline GenJet& operator=(const GenJet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenJet& default_instance();
  
  void Swap(GenJet* other);
  
  // implements Message ----------------------------------------------
  
  GenJet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenJet& from);
  void MergeFrom(const GenJet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double Energy = 1 [default = 0];
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 1;
  inline double energy() const;
  inline void set_energy(double value);
  
  // optional double Px = 2 [default = 0];
  inline bool has_px() const;
  inline void clear_px();
  static const int kPxFieldNumber = 2;
  inline double px() const;
  inline void set_px(double value);
  
  // optional double Py = 3 [default = 0];
  inline bool has_py() const;
  inline void clear_py();
  static const int kPyFieldNumber = 3;
  inline double py() const;
  inline void set_py(double value);
  
  // optional double Pz = 4 [default = 0];
  inline bool has_pz() const;
  inline void clear_pz();
  static const int kPzFieldNumber = 4;
  inline double pz() const;
  inline void set_pz(double value);
  
  // optional double Charge = 5 [default = 0];
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 5;
  inline double charge() const;
  inline void set_charge(double value);
  
  // optional double Mass = 6 [default = 0];
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 6;
  inline double mass() const;
  inline void set_mass(double value);
  
  // optional double Eta = 7 [default = 0];
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 7;
  inline double eta() const;
  inline void set_eta(double value);
  
  // optional double Phi = 8 [default = 0];
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 8;
  inline double phi() const;
  inline void set_phi(double value);
  
  // optional double Pt = 9 [default = 0];
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 9;
  inline double pt() const;
  inline void set_pt(double value);
  
  // optional double EMF = 10 [default = 0];
  inline bool has_emf() const;
  inline void clear_emf();
  static const int kEMFFieldNumber = 10;
  inline double emf() const;
  inline void set_emf(double value);
  
  // optional double HADF = 11 [default = 0];
  inline bool has_hadf() const;
  inline void clear_hadf();
  static const int kHADFFieldNumber = 11;
  inline double hadf() const;
  inline void set_hadf(double value);
  
  // @@protoc_insertion_point(class_scope:HEP.GenJet)
 private:
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_px();
  inline void clear_has_px();
  inline void set_has_py();
  inline void clear_has_py();
  inline void set_has_pz();
  inline void clear_has_pz();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_pt();
  inline void clear_has_pt();
  inline void set_has_emf();
  inline void clear_has_emf();
  inline void set_has_hadf();
  inline void clear_has_hadf();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double energy_;
  double px_;
  double py_;
  double pz_;
  double charge_;
  double mass_;
  double eta_;
  double phi_;
  double pt_;
  double emf_;
  double hadf_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static GenJet* default_instance_;
};
// -------------------------------------------------------------------

class GenParticle : public ::google::protobuf::Message {
 public:
  GenParticle();
  virtual ~GenParticle();
  
  GenParticle(const GenParticle& from);
  
  inline GenParticle& operator=(const GenParticle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenParticle& default_instance();
  
  void Swap(GenParticle* other);
  
  // implements Message ----------------------------------------------
  
  GenParticle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenParticle& from);
  void MergeFrom(const GenParticle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double Energy = 1 [default = 0];
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 1;
  inline double energy() const;
  inline void set_energy(double value);
  
  // optional double Px = 2 [default = 0];
  inline bool has_px() const;
  inline void clear_px();
  static const int kPxFieldNumber = 2;
  inline double px() const;
  inline void set_px(double value);
  
  // optional double Py = 3 [default = 0];
  inline bool has_py() const;
  inline void clear_py();
  static const int kPyFieldNumber = 3;
  inline double py() const;
  inline void set_py(double value);
  
  // optional double Pz = 4 [default = 0];
  inline bool has_pz() const;
  inline void clear_pz();
  static const int kPzFieldNumber = 4;
  inline double pz() const;
  inline void set_pz(double value);
  
  // optional double Charge = 5 [default = 0];
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 5;
  inline double charge() const;
  inline void set_charge(double value);
  
  // optional double Mass = 6 [default = 0];
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 6;
  inline double mass() const;
  inline void set_mass(double value);
  
  // optional double Eta = 7 [default = 0];
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 7;
  inline double eta() const;
  inline void set_eta(double value);
  
  // optional double Phi = 8 [default = 0];
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 8;
  inline double phi() const;
  inline void set_phi(double value);
  
  // optional double Pt = 9 [default = 0];
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 9;
  inline double pt() const;
  inline void set_pt(double value);
  
  // optional int32 PdgId = 10 [default = 0];
  inline bool has_pdgid() const;
  inline void clear_pdgid();
  static const int kPdgIdFieldNumber = 10;
  inline ::google::protobuf::int32 pdgid() const;
  inline void set_pdgid(::google::protobuf::int32 value);
  
  // optional double VX = 11 [default = 0];
  inline bool has_vx() const;
  inline void clear_vx();
  static const int kVXFieldNumber = 11;
  inline double vx() const;
  inline void set_vx(double value);
  
  // optional double VY = 12 [default = 0];
  inline bool has_vy() const;
  inline void clear_vy();
  static const int kVYFieldNumber = 12;
  inline double vy() const;
  inline void set_vy(double value);
  
  // optional double VZ = 13 [default = 0];
  inline bool has_vz() const;
  inline void clear_vz();
  static const int kVZFieldNumber = 13;
  inline double vz() const;
  inline void set_vz(double value);
  
  // optional int32 NumDaught = 14 [default = 0];
  inline bool has_numdaught() const;
  inline void clear_numdaught();
  static const int kNumDaughtFieldNumber = 14;
  inline ::google::protobuf::int32 numdaught() const;
  inline void set_numdaught(::google::protobuf::int32 value);
  
  // optional int32 Status = 15 [default = 0];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 15;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional int32 MotherIndex = 16 [default = 0];
  inline bool has_motherindex() const;
  inline void clear_motherindex();
  static const int kMotherIndexFieldNumber = 16;
  inline ::google::protobuf::int32 motherindex() const;
  inline void set_motherindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:HEP.GenParticle)
 private:
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_px();
  inline void clear_has_px();
  inline void set_has_py();
  inline void clear_has_py();
  inline void set_has_pz();
  inline void clear_has_pz();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_pt();
  inline void clear_has_pt();
  inline void set_has_pdgid();
  inline void clear_has_pdgid();
  inline void set_has_vx();
  inline void clear_has_vx();
  inline void set_has_vy();
  inline void clear_has_vy();
  inline void set_has_vz();
  inline void clear_has_vz();
  inline void set_has_numdaught();
  inline void clear_has_numdaught();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_motherindex();
  inline void clear_has_motherindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double energy_;
  double px_;
  double py_;
  double pz_;
  double charge_;
  double mass_;
  double eta_;
  double phi_;
  double pt_;
  double vx_;
  double vy_;
  ::google::protobuf::int32 pdgid_;
  ::google::protobuf::int32 numdaught_;
  double vz_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 motherindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static GenParticle* default_instance_;
};
// -------------------------------------------------------------------

class Electron_GSFTrack : public ::google::protobuf::Message {
 public:
  Electron_GSFTrack();
  virtual ~Electron_GSFTrack();
  
  Electron_GSFTrack(const Electron_GSFTrack& from);
  
  inline Electron_GSFTrack& operator=(const Electron_GSFTrack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Electron_GSFTrack& default_instance();
  
  void Swap(Electron_GSFTrack* other);
  
  // implements Message ----------------------------------------------
  
  Electron_GSFTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Electron_GSFTrack& from);
  void MergeFrom(const Electron_GSFTrack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double d0 = 1 [default = 0];
  inline bool has_d0() const;
  inline void clear_d0();
  static const int kD0FieldNumber = 1;
  inline double d0() const;
  inline void set_d0(double value);
  
  // optional double Eta = 2 [default = 0];
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 2;
  inline double eta() const;
  inline void set_eta(double value);
  
  // optional double Phi = 3 [default = 0];
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 3;
  inline double phi() const;
  inline void set_phi(double value);
  
  // optional double Theta = 4 [default = 0];
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 4;
  inline double theta() const;
  inline void set_theta(double value);
  
  // optional int32 Charge = 5 [default = 0];
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 5;
  inline ::google::protobuf::int32 charge() const;
  inline void set_charge(::google::protobuf::int32 value);
  
  // optional double Pt = 6 [default = 0];
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 6;
  inline double pt() const;
  inline void set_pt(double value);
  
  // @@protoc_insertion_point(class_scope:HEP.Electron.GSFTrack)
 private:
  inline void set_has_d0();
  inline void clear_has_d0();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_theta();
  inline void clear_has_theta();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_pt();
  inline void clear_has_pt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double d0_;
  double eta_;
  double phi_;
  double theta_;
  double pt_;
  ::google::protobuf::int32 charge_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Electron_GSFTrack* default_instance_;
};
// -------------------------------------------------------------------

class Electron : public ::google::protobuf::Message {
 public:
  Electron();
  virtual ~Electron();
  
  Electron(const Electron& from);
  
  inline Electron& operator=(const Electron& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Electron& default_instance();
  
  void Swap(Electron* other);
  
  // implements Message ----------------------------------------------
  
  Electron* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Electron& from);
  void MergeFrom(const Electron& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Electron_GSFTrack GSFTrack;
  
  typedef Electron_ElectronAlgorithm ElectronAlgorithm;
  static const ElectronAlgorithm Calo = Electron_ElectronAlgorithm_Calo;
  static const ElectronAlgorithm ParticleFlow = Electron_ElectronAlgorithm_ParticleFlow;
  static inline bool ElectronAlgorithm_IsValid(int value) {
    return Electron_ElectronAlgorithm_IsValid(value);
  }
  static const ElectronAlgorithm ElectronAlgorithm_MIN =
    Electron_ElectronAlgorithm_ElectronAlgorithm_MIN;
  static const ElectronAlgorithm ElectronAlgorithm_MAX =
    Electron_ElectronAlgorithm_ElectronAlgorithm_MAX;
  static const int ElectronAlgorithm_ARRAYSIZE =
    Electron_ElectronAlgorithm_ElectronAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ElectronAlgorithm_descriptor() {
    return Electron_ElectronAlgorithm_descriptor();
  }
  static inline const ::std::string& ElectronAlgorithm_Name(ElectronAlgorithm value) {
    return Electron_ElectronAlgorithm_Name(value);
  }
  static inline bool ElectronAlgorithm_Parse(const ::std::string& name,
      ElectronAlgorithm* value) {
    return Electron_ElectronAlgorithm_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional double Energy = 1 [default = 0];
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 1;
  inline double energy() const;
  inline void set_energy(double value);
  
  // optional double Px = 2 [default = 0];
  inline bool has_px() const;
  inline void clear_px();
  static const int kPxFieldNumber = 2;
  inline double px() const;
  inline void set_px(double value);
  
  // optional double Py = 3 [default = 0];
  inline bool has_py() const;
  inline void clear_py();
  static const int kPyFieldNumber = 3;
  inline double py() const;
  inline void set_py(double value);
  
  // optional double Pz = 4 [default = 0];
  inline bool has_pz() const;
  inline void clear_pz();
  static const int kPzFieldNumber = 4;
  inline double pz() const;
  inline void set_pz(double value);
  
  // optional double Charge = 5 [default = 0];
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 5;
  inline double charge() const;
  inline void set_charge(double value);
  
  // optional int32 Mass = 6 [default = 0];
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 6;
  inline ::google::protobuf::int32 mass() const;
  inline void set_mass(::google::protobuf::int32 value);
  
  // optional .HEP.Electron.ElectronAlgorithm type = 7 [default = ParticleFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::HEP::Electron_ElectronAlgorithm type() const;
  inline void set_type(::HEP::Electron_ElectronAlgorithm value);
  
  // optional double Eta = 8 [default = 0];
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 8;
  inline double eta() const;
  inline void set_eta(double value);
  
  // optional double Phi = 9 [default = 0];
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 9;
  inline double phi() const;
  inline void set_phi(double value);
  
  // optional double Pt = 10 [default = 0];
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 10;
  inline double pt() const;
  inline void set_pt(double value);
  
  // optional double CaloEnergy = 12 [default = 0];
  inline bool has_caloenergy() const;
  inline void clear_caloenergy();
  static const int kCaloEnergyFieldNumber = 12;
  inline double caloenergy() const;
  inline void set_caloenergy(double value);
  
  // optional double HoE = 13 [default = 0];
  inline bool has_hoe() const;
  inline void clear_hoe();
  static const int kHoEFieldNumber = 13;
  inline double hoe() const;
  inline void set_hoe(double value);
  
  // optional double eSeedClusterOverPout = 14 [default = 0];
  inline bool has_eseedclusteroverpout() const;
  inline void clear_eseedclusteroverpout();
  static const int kESeedClusterOverPoutFieldNumber = 14;
  inline double eseedclusteroverpout() const;
  inline void set_eseedclusteroverpout(double value);
  
  // optional double EoverP = 15 [default = 0];
  inline bool has_eoverp() const;
  inline void clear_eoverp();
  static const int kEoverPFieldNumber = 15;
  inline double eoverp() const;
  inline void set_eoverp(double value);
  
  // optional double fbrem = 16 [default = 0];
  inline bool has_fbrem() const;
  inline void clear_fbrem();
  static const int kFbremFieldNumber = 16;
  inline double fbrem() const;
  inline void set_fbrem(double value);
  
  // optional double SigmaEtaEta = 17 [default = 0];
  inline bool has_sigmaetaeta() const;
  inline void clear_sigmaetaeta();
  static const int kSigmaEtaEtaFieldNumber = 17;
  inline double sigmaetaeta() const;
  inline void set_sigmaetaeta(double value);
  
  // optional double SigmaIEtaIEta = 18 [default = 0];
  inline bool has_sigmaietaieta() const;
  inline void clear_sigmaietaieta();
  static const int kSigmaIEtaIEtaFieldNumber = 18;
  inline double sigmaietaieta() const;
  inline void set_sigmaietaieta(double value);
  
  // optional double DeltaPhiTrkSC = 19 [default = 0];
  inline bool has_deltaphitrksc() const;
  inline void clear_deltaphitrksc();
  static const int kDeltaPhiTrkSCFieldNumber = 19;
  inline double deltaphitrksc() const;
  inline void set_deltaphitrksc(double value);
  
  // optional double DeltaEtaTrkSC = 20 [default = 0];
  inline bool has_deltaetatrksc() const;
  inline void clear_deltaetatrksc();
  static const int kDeltaEtaTrkSCFieldNumber = 20;
  inline double deltaetatrksc() const;
  inline void set_deltaetatrksc(double value);
  
  // optional double TrkIso03 = 21 [default = 0];
  inline bool has_trkiso03() const;
  inline void clear_trkiso03();
  static const int kTrkIso03FieldNumber = 21;
  inline double trkiso03() const;
  inline void set_trkiso03(double value);
  
  // optional double EcalIso03 = 22 [default = 0];
  inline bool has_ecaliso03() const;
  inline void clear_ecaliso03();
  static const int kEcalIso03FieldNumber = 22;
  inline double ecaliso03() const;
  inline void set_ecaliso03(double value);
  
  // optional double HcalIso03 = 23 [default = 0];
  inline bool has_hcaliso03() const;
  inline void clear_hcaliso03();
  static const int kHcalIso03FieldNumber = 23;
  inline double hcaliso03() const;
  inline void set_hcaliso03(double value);
  
  // optional double TrkIso = 24 [default = 0];
  inline bool has_trkiso() const;
  inline void clear_trkiso();
  static const int kTrkIsoFieldNumber = 24;
  inline double trkiso() const;
  inline void set_trkiso(double value);
  
  // optional double EcalIso = 25 [default = 0];
  inline bool has_ecaliso() const;
  inline void clear_ecaliso();
  static const int kEcalIsoFieldNumber = 25;
  inline double ecaliso() const;
  inline void set_ecaliso(double value);
  
  // optional double HcalIso = 26 [default = 0];
  inline bool has_hcaliso() const;
  inline void clear_hcaliso();
  static const int kHcalIsoFieldNumber = 26;
  inline double hcaliso() const;
  inline void set_hcaliso(double value);
  
  // optional double dB = 27 [default = 0];
  inline bool has_db() const;
  inline void clear_db();
  static const int kDBFieldNumber = 27;
  inline double db() const;
  inline void set_db(double value);
  
  // optional int32 closestCtfTrackRef = 28 [default = 0];
  inline bool has_closestctftrackref() const;
  inline void clear_closestctftrackref();
  static const int kClosestCtfTrackRefFieldNumber = 28;
  inline ::google::protobuf::int32 closestctftrackref() const;
  inline void set_closestctftrackref(::google::protobuf::int32 value);
  
  // optional double shFracInnerHits = 29 [default = 0];
  inline bool has_shfracinnerhits() const;
  inline void clear_shfracinnerhits();
  static const int kShFracInnerHitsFieldNumber = 29;
  inline double shfracinnerhits() const;
  inline void set_shfracinnerhits(double value);
  
  // repeated .HEP.Electron.GSFTrack track = 30;
  inline int track_size() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 30;
  inline const ::HEP::Electron_GSFTrack& track(int index) const;
  inline ::HEP::Electron_GSFTrack* mutable_track(int index);
  inline ::HEP::Electron_GSFTrack* add_track();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Electron_GSFTrack >&
      track() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Electron_GSFTrack >*
      mutable_track();
  
  // optional double EcalIsoHeep = 31 [default = 0];
  inline bool has_ecalisoheep() const;
  inline void clear_ecalisoheep();
  static const int kEcalIsoHeepFieldNumber = 31;
  inline double ecalisoheep() const;
  inline void set_ecalisoheep(double value);
  
  // optional double HcalIsoD1Heep = 32 [default = 0];
  inline bool has_hcalisod1heep() const;
  inline void clear_hcalisod1heep();
  static const int kHcalIsoD1HeepFieldNumber = 32;
  inline double hcalisod1heep() const;
  inline void set_hcalisod1heep(double value);
  
  // optional double HcalIsoD2Heep = 33 [default = 0];
  inline bool has_hcalisod2heep() const;
  inline void clear_hcalisod2heep();
  static const int kHcalIsoD2HeepFieldNumber = 33;
  inline double hcalisod2heep() const;
  inline void set_hcalisod2heep(double value);
  
  // optional double TrkIsoHeep = 34 [default = 0];
  inline bool has_trkisoheep() const;
  inline void clear_trkisoheep();
  static const int kTrkIsoHeepFieldNumber = 34;
  inline double trkisoheep() const;
  inline void set_trkisoheep(double value);
  
  // optional int32 MissingHits = 35 [default = 0];
  inline bool has_missinghits() const;
  inline void clear_missinghits();
  static const int kMissingHitsFieldNumber = 35;
  inline ::google::protobuf::int32 missinghits() const;
  inline void set_missinghits(::google::protobuf::int32 value);
  
  // optional double Dist = 36 [default = 0];
  inline bool has_dist() const;
  inline void clear_dist();
  static const int kDistFieldNumber = 36;
  inline double dist() const;
  inline void set_dist(double value);
  
  // optional double DCotTheta = 37 [default = 0];
  inline bool has_dcottheta() const;
  inline void clear_dcottheta();
  static const int kDCotThetaFieldNumber = 37;
  inline double dcottheta() const;
  inline void set_dcottheta(double value);
  
  // optional double SCEta = 38 [default = 0];
  inline bool has_sceta() const;
  inline void clear_sceta();
  static const int kSCEtaFieldNumber = 38;
  inline double sceta() const;
  inline void set_sceta(double value);
  
  // optional double SCPhi = 39 [default = 0];
  inline bool has_scphi() const;
  inline void clear_scphi();
  static const int kSCPhiFieldNumber = 39;
  inline double scphi() const;
  inline void set_scphi(double value);
  
  // optional double SCPt = 40 [default = 0];
  inline bool has_scpt() const;
  inline void clear_scpt();
  static const int kSCPtFieldNumber = 40;
  inline double scpt() const;
  inline void set_scpt(double value);
  
  // optional double SCRawEnergy = 41 [default = 0];
  inline bool has_scrawenergy() const;
  inline void clear_scrawenergy();
  static const int kSCRawEnergyFieldNumber = 41;
  inline double scrawenergy() const;
  inline void set_scrawenergy(double value);
  
  // optional int32 VtxIndex = 42 [default = 0];
  inline bool has_vtxindex() const;
  inline void clear_vtxindex();
  static const int kVtxIndexFieldNumber = 42;
  inline ::google::protobuf::int32 vtxindex() const;
  inline void set_vtxindex(::google::protobuf::int32 value);
  
  // optional double VtxDistXY = 43 [default = 0];
  inline bool has_vtxdistxy() const;
  inline void clear_vtxdistxy();
  static const int kVtxDistXYFieldNumber = 43;
  inline double vtxdistxy() const;
  inline void set_vtxdistxy(double value);
  
  // optional double VtxDistZ = 44 [default = 0];
  inline bool has_vtxdistz() const;
  inline void clear_vtxdistz();
  static const int kVtxDistZFieldNumber = 44;
  inline double vtxdistz() const;
  inline void set_vtxdistz(double value);
  
  // optional double VertexX = 45 [default = 0];
  inline bool has_vertexx() const;
  inline void clear_vertexx();
  static const int kVertexXFieldNumber = 45;
  inline double vertexx() const;
  inline void set_vertexx(double value);
  
  // optional double VertexY = 46 [default = 0];
  inline bool has_vertexy() const;
  inline void clear_vertexy();
  static const int kVertexYFieldNumber = 46;
  inline double vertexy() const;
  inline void set_vertexy(double value);
  
  // optional double VertexZ = 47 [default = 0];
  inline bool has_vertexz() const;
  inline void clear_vertexz();
  static const int kVertexZFieldNumber = 47;
  inline double vertexz() const;
  inline void set_vertexz(double value);
  
  // optional int32 PassID = 48 [default = 0];
  inline bool has_passid() const;
  inline void clear_passid();
  static const int kPassIDFieldNumber = 48;
  inline ::google::protobuf::int32 passid() const;
  inline void set_passid(::google::protobuf::int32 value);
  
  // optional double PfChargedHadronIso = 49 [default = 0];
  inline bool has_pfchargedhadroniso() const;
  inline void clear_pfchargedhadroniso();
  static const int kPfChargedHadronIsoFieldNumber = 49;
  inline double pfchargedhadroniso() const;
  inline void set_pfchargedhadroniso(double value);
  
  // optional double PfNeutralHadronIso = 50 [default = 0];
  inline bool has_pfneutralhadroniso() const;
  inline void clear_pfneutralhadroniso();
  static const int kPfNeutralHadronIsoFieldNumber = 50;
  inline double pfneutralhadroniso() const;
  inline void set_pfneutralhadroniso(double value);
  
  // optional double PFGammaIso = 51 [default = 0];
  inline bool has_pfgammaiso() const;
  inline void clear_pfgammaiso();
  static const int kPFGammaIsoFieldNumber = 51;
  inline double pfgammaiso() const;
  inline void set_pfgammaiso(double value);
  
  // @@protoc_insertion_point(class_scope:HEP.Electron)
 private:
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_px();
  inline void clear_has_px();
  inline void set_has_py();
  inline void clear_has_py();
  inline void set_has_pz();
  inline void clear_has_pz();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_pt();
  inline void clear_has_pt();
  inline void set_has_caloenergy();
  inline void clear_has_caloenergy();
  inline void set_has_hoe();
  inline void clear_has_hoe();
  inline void set_has_eseedclusteroverpout();
  inline void clear_has_eseedclusteroverpout();
  inline void set_has_eoverp();
  inline void clear_has_eoverp();
  inline void set_has_fbrem();
  inline void clear_has_fbrem();
  inline void set_has_sigmaetaeta();
  inline void clear_has_sigmaetaeta();
  inline void set_has_sigmaietaieta();
  inline void clear_has_sigmaietaieta();
  inline void set_has_deltaphitrksc();
  inline void clear_has_deltaphitrksc();
  inline void set_has_deltaetatrksc();
  inline void clear_has_deltaetatrksc();
  inline void set_has_trkiso03();
  inline void clear_has_trkiso03();
  inline void set_has_ecaliso03();
  inline void clear_has_ecaliso03();
  inline void set_has_hcaliso03();
  inline void clear_has_hcaliso03();
  inline void set_has_trkiso();
  inline void clear_has_trkiso();
  inline void set_has_ecaliso();
  inline void clear_has_ecaliso();
  inline void set_has_hcaliso();
  inline void clear_has_hcaliso();
  inline void set_has_db();
  inline void clear_has_db();
  inline void set_has_closestctftrackref();
  inline void clear_has_closestctftrackref();
  inline void set_has_shfracinnerhits();
  inline void clear_has_shfracinnerhits();
  inline void set_has_ecalisoheep();
  inline void clear_has_ecalisoheep();
  inline void set_has_hcalisod1heep();
  inline void clear_has_hcalisod1heep();
  inline void set_has_hcalisod2heep();
  inline void clear_has_hcalisod2heep();
  inline void set_has_trkisoheep();
  inline void clear_has_trkisoheep();
  inline void set_has_missinghits();
  inline void clear_has_missinghits();
  inline void set_has_dist();
  inline void clear_has_dist();
  inline void set_has_dcottheta();
  inline void clear_has_dcottheta();
  inline void set_has_sceta();
  inline void clear_has_sceta();
  inline void set_has_scphi();
  inline void clear_has_scphi();
  inline void set_has_scpt();
  inline void clear_has_scpt();
  inline void set_has_scrawenergy();
  inline void clear_has_scrawenergy();
  inline void set_has_vtxindex();
  inline void clear_has_vtxindex();
  inline void set_has_vtxdistxy();
  inline void clear_has_vtxdistxy();
  inline void set_has_vtxdistz();
  inline void clear_has_vtxdistz();
  inline void set_has_vertexx();
  inline void clear_has_vertexx();
  inline void set_has_vertexy();
  inline void clear_has_vertexy();
  inline void set_has_vertexz();
  inline void clear_has_vertexz();
  inline void set_has_passid();
  inline void clear_has_passid();
  inline void set_has_pfchargedhadroniso();
  inline void clear_has_pfchargedhadroniso();
  inline void set_has_pfneutralhadroniso();
  inline void clear_has_pfneutralhadroniso();
  inline void set_has_pfgammaiso();
  inline void clear_has_pfgammaiso();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double energy_;
  double px_;
  double py_;
  double pz_;
  double charge_;
  ::google::protobuf::int32 mass_;
  int type_;
  double eta_;
  double phi_;
  double pt_;
  double caloenergy_;
  double hoe_;
  double eseedclusteroverpout_;
  double eoverp_;
  double fbrem_;
  double sigmaetaeta_;
  double sigmaietaieta_;
  double deltaphitrksc_;
  double deltaetatrksc_;
  double trkiso03_;
  double ecaliso03_;
  double hcaliso03_;
  double trkiso_;
  double ecaliso_;
  double hcaliso_;
  double db_;
  double shfracinnerhits_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Electron_GSFTrack > track_;
  double ecalisoheep_;
  ::google::protobuf::int32 closestctftrackref_;
  ::google::protobuf::int32 missinghits_;
  double hcalisod1heep_;
  double hcalisod2heep_;
  double trkisoheep_;
  double dist_;
  double dcottheta_;
  double sceta_;
  double scphi_;
  double scpt_;
  double scrawenergy_;
  double vtxdistxy_;
  double vtxdistz_;
  double vertexx_;
  ::google::protobuf::int32 vtxindex_;
  ::google::protobuf::int32 passid_;
  double vertexy_;
  double vertexz_;
  double pfchargedhadroniso_;
  double pfneutralhadroniso_;
  double pfgammaiso_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(50 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Electron* default_instance_;
};
// -------------------------------------------------------------------

class Muon : public ::google::protobuf::Message {
 public:
  Muon();
  virtual ~Muon();
  
  Muon(const Muon& from);
  
  inline Muon& operator=(const Muon& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Muon& default_instance();
  
  void Swap(Muon* other);
  
  // implements Message ----------------------------------------------
  
  Muon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Muon& from);
  void MergeFrom(const Muon& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Muon_MuonAlgorithm MuonAlgorithm;
  static const MuonAlgorithm Default = Muon_MuonAlgorithm_Default;
  static const MuonAlgorithm ParticleFlow = Muon_MuonAlgorithm_ParticleFlow;
  static inline bool MuonAlgorithm_IsValid(int value) {
    return Muon_MuonAlgorithm_IsValid(value);
  }
  static const MuonAlgorithm MuonAlgorithm_MIN =
    Muon_MuonAlgorithm_MuonAlgorithm_MIN;
  static const MuonAlgorithm MuonAlgorithm_MAX =
    Muon_MuonAlgorithm_MuonAlgorithm_MAX;
  static const int MuonAlgorithm_ARRAYSIZE =
    Muon_MuonAlgorithm_MuonAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MuonAlgorithm_descriptor() {
    return Muon_MuonAlgorithm_descriptor();
  }
  static inline const ::std::string& MuonAlgorithm_Name(MuonAlgorithm value) {
    return Muon_MuonAlgorithm_Name(value);
  }
  static inline bool MuonAlgorithm_Parse(const ::std::string& name,
      MuonAlgorithm* value) {
    return Muon_MuonAlgorithm_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional double Energy = 1 [default = 0];
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 1;
  inline double energy() const;
  inline void set_energy(double value);
  
  // optional double Px = 2 [default = 0];
  inline bool has_px() const;
  inline void clear_px();
  static const int kPxFieldNumber = 2;
  inline double px() const;
  inline void set_px(double value);
  
  // optional double Py = 3 [default = 0];
  inline bool has_py() const;
  inline void clear_py();
  static const int kPyFieldNumber = 3;
  inline double py() const;
  inline void set_py(double value);
  
  // optional double Pz = 4 [default = 0];
  inline bool has_pz() const;
  inline void clear_pz();
  static const int kPzFieldNumber = 4;
  inline double pz() const;
  inline void set_pz(double value);
  
  // optional int32 Charge = 5 [default = 0];
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 5;
  inline ::google::protobuf::int32 charge() const;
  inline void set_charge(::google::protobuf::int32 value);
  
  // optional double Mass = 6 [default = 0];
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 6;
  inline double mass() const;
  inline void set_mass(double value);
  
  // optional double TrkIso03 = 7 [default = 0];
  inline bool has_trkiso03() const;
  inline void clear_trkiso03();
  static const int kTrkIso03FieldNumber = 7;
  inline double trkiso03() const;
  inline void set_trkiso03(double value);
  
  // optional double EcalIso03 = 8 [default = 0];
  inline bool has_ecaliso03() const;
  inline void clear_ecaliso03();
  static const int kEcalIso03FieldNumber = 8;
  inline double ecaliso03() const;
  inline void set_ecaliso03(double value);
  
  // optional double HcalIso03 = 9 [default = 0];
  inline bool has_hcaliso03() const;
  inline void clear_hcaliso03();
  static const int kHcalIso03FieldNumber = 9;
  inline double hcaliso03() const;
  inline void set_hcaliso03(double value);
  
  // optional int32 isGoodGlobalMuon = 10 [default = 0];
  inline bool has_isgoodglobalmuon() const;
  inline void clear_isgoodglobalmuon();
  static const int kIsGoodGlobalMuonFieldNumber = 10;
  inline ::google::protobuf::int32 isgoodglobalmuon() const;
  inline void set_isgoodglobalmuon(::google::protobuf::int32 value);
  
  // optional double PfChargedHadronIso = 11 [default = 0];
  inline bool has_pfchargedhadroniso() const;
  inline void clear_pfchargedhadroniso();
  static const int kPfChargedHadronIsoFieldNumber = 11;
  inline double pfchargedhadroniso() const;
  inline void set_pfchargedhadroniso(double value);
  
  // optional double PfNeutralHadronIso = 12 [default = 0];
  inline bool has_pfneutralhadroniso() const;
  inline void clear_pfneutralhadroniso();
  static const int kPfNeutralHadronIsoFieldNumber = 12;
  inline double pfneutralhadroniso() const;
  inline void set_pfneutralhadroniso(double value);
  
  // optional double PFGammaIso = 13 [default = 0];
  inline bool has_pfgammaiso() const;
  inline void clear_pfgammaiso();
  static const int kPFGammaIsoFieldNumber = 13;
  inline double pfgammaiso() const;
  inline void set_pfgammaiso(double value);
  
  // optional double Eta = 14 [default = 0];
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 14;
  inline double eta() const;
  inline void set_eta(double value);
  
  // optional double Phi = 15 [default = 0];
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 15;
  inline double phi() const;
  inline void set_phi(double value);
  
  // optional double Pt = 16 [default = 0];
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 16;
  inline double pt() const;
  inline void set_pt(double value);
  
  // optional double P = 17 [default = 0];
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 17;
  inline double p() const;
  inline void set_p(double value);
  
  // optional int32 TrkHits = 18 [default = 0];
  inline bool has_trkhits() const;
  inline void clear_trkhits();
  static const int kTrkHitsFieldNumber = 18;
  inline ::google::protobuf::int32 trkhits() const;
  inline void set_trkhits(::google::protobuf::int32 value);
  
  // optional double TrkD0 = 19 [default = 0];
  inline bool has_trkd0() const;
  inline void clear_trkd0();
  static const int kTrkD0FieldNumber = 19;
  inline double trkd0() const;
  inline void set_trkd0(double value);
  
  // optional double TrkD0Error = 20 [default = 0];
  inline bool has_trkd0error() const;
  inline void clear_trkd0error();
  static const int kTrkD0ErrorFieldNumber = 20;
  inline double trkd0error() const;
  inline void set_trkd0error(double value);
  
  // optional double TrkDz = 21 [default = 0];
  inline bool has_trkdz() const;
  inline void clear_trkdz();
  static const int kTrkDzFieldNumber = 21;
  inline double trkdz() const;
  inline void set_trkdz(double value);
  
  // optional double TrkDzError = 22 [default = 0];
  inline bool has_trkdzerror() const;
  inline void clear_trkdzerror();
  static const int kTrkDzErrorFieldNumber = 22;
  inline double trkdzerror() const;
  inline void set_trkdzerror(double value);
  
  // optional double GlobalChi2 = 23 [default = 0];
  inline bool has_globalchi2() const;
  inline void clear_globalchi2();
  static const int kGlobalChi2FieldNumber = 23;
  inline double globalchi2() const;
  inline void set_globalchi2(double value);
  
  // optional double TrkIso = 24 [default = 0];
  inline bool has_trkiso() const;
  inline void clear_trkiso();
  static const int kTrkIsoFieldNumber = 24;
  inline double trkiso() const;
  inline void set_trkiso(double value);
  
  // optional double EcalIso = 25 [default = 0];
  inline bool has_ecaliso() const;
  inline void clear_ecaliso();
  static const int kEcalIsoFieldNumber = 25;
  inline double ecaliso() const;
  inline void set_ecaliso(double value);
  
  // optional double HcalIso = 26 [default = 0];
  inline bool has_hcaliso() const;
  inline void clear_hcaliso();
  static const int kHcalIsoFieldNumber = 26;
  inline double hcaliso() const;
  inline void set_hcaliso(double value);
  
  // optional double HOIso = 27 [default = 0];
  inline bool has_hoiso() const;
  inline void clear_hoiso();
  static const int kHOIsoFieldNumber = 27;
  inline double hoiso() const;
  inline void set_hoiso(double value);
  
  // optional int32 VtxIndex = 28 [default = 0];
  inline bool has_vtxindex() const;
  inline void clear_vtxindex();
  static const int kVtxIndexFieldNumber = 28;
  inline ::google::protobuf::int32 vtxindex() const;
  inline void set_vtxindex(::google::protobuf::int32 value);
  
  // optional double VtxDistXY = 29 [default = 0];
  inline bool has_vtxdistxy() const;
  inline void clear_vtxdistxy();
  static const int kVtxDistXYFieldNumber = 29;
  inline double vtxdistxy() const;
  inline void set_vtxdistxy(double value);
  
  // optional double VtxDistZ = 30 [default = 0];
  inline bool has_vtxdistz() const;
  inline void clear_vtxdistz();
  static const int kVtxDistZFieldNumber = 30;
  inline double vtxdistz() const;
  inline void set_vtxdistz(double value);
  
  // optional double CocktailEta = 31 [default = 0];
  inline bool has_cocktaileta() const;
  inline void clear_cocktaileta();
  static const int kCocktailEtaFieldNumber = 31;
  inline double cocktaileta() const;
  inline void set_cocktaileta(double value);
  
  // optional double CocktailPhi = 32 [default = 0];
  inline bool has_cocktailphi() const;
  inline void clear_cocktailphi();
  static const int kCocktailPhiFieldNumber = 32;
  inline double cocktailphi() const;
  inline void set_cocktailphi(double value);
  
  // optional double CocktailPt = 33 [default = 0];
  inline bool has_cocktailpt() const;
  inline void clear_cocktailpt();
  static const int kCocktailPtFieldNumber = 33;
  inline double cocktailpt() const;
  inline void set_cocktailpt(double value);
  
  // optional double CocktailP = 34 [default = 0];
  inline bool has_cocktailp() const;
  inline void clear_cocktailp();
  static const int kCocktailPFieldNumber = 34;
  inline double cocktailp() const;
  inline void set_cocktailp(double value);
  
  // optional int32 CocktailCharge = 35 [default = 0];
  inline bool has_cocktailcharge() const;
  inline void clear_cocktailcharge();
  static const int kCocktailChargeFieldNumber = 35;
  inline ::google::protobuf::int32 cocktailcharge() const;
  inline void set_cocktailcharge(::google::protobuf::int32 value);
  
  // optional int32 CocktailTrkHits = 36 [default = 0];
  inline bool has_cocktailtrkhits() const;
  inline void clear_cocktailtrkhits();
  static const int kCocktailTrkHitsFieldNumber = 36;
  inline ::google::protobuf::int32 cocktailtrkhits() const;
  inline void set_cocktailtrkhits(::google::protobuf::int32 value);
  
  // optional double CocktailTrkD0 = 37 [default = 0];
  inline bool has_cocktailtrkd0() const;
  inline void clear_cocktailtrkd0();
  static const int kCocktailTrkD0FieldNumber = 37;
  inline double cocktailtrkd0() const;
  inline void set_cocktailtrkd0(double value);
  
  // optional double CocktailTrkD0Error = 38 [default = 0];
  inline bool has_cocktailtrkd0error() const;
  inline void clear_cocktailtrkd0error();
  static const int kCocktailTrkD0ErrorFieldNumber = 38;
  inline double cocktailtrkd0error() const;
  inline void set_cocktailtrkd0error(double value);
  
  // optional double CocktailTrkDz = 39 [default = 0];
  inline bool has_cocktailtrkdz() const;
  inline void clear_cocktailtrkdz();
  static const int kCocktailTrkDzFieldNumber = 39;
  inline double cocktailtrkdz() const;
  inline void set_cocktailtrkdz(double value);
  
  // optional double CocktailTrkDzError = 40 [default = 0];
  inline bool has_cocktailtrkdzerror() const;
  inline void clear_cocktailtrkdzerror();
  static const int kCocktailTrkDzErrorFieldNumber = 40;
  inline double cocktailtrkdzerror() const;
  inline void set_cocktailtrkdzerror(double value);
  
  // optional double CocktailGlobalChi2 = 41 [default = 0];
  inline bool has_cocktailglobalchi2() const;
  inline void clear_cocktailglobalchi2();
  static const int kCocktailGlobalChi2FieldNumber = 41;
  inline double cocktailglobalchi2() const;
  inline void set_cocktailglobalchi2(double value);
  
  // optional .HEP.Muon.MuonAlgorithm type = 42 [default = ParticleFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 42;
  inline ::HEP::Muon_MuonAlgorithm type() const;
  inline void set_type(::HEP::Muon_MuonAlgorithm value);
  
  // @@protoc_insertion_point(class_scope:HEP.Muon)
 private:
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_px();
  inline void clear_has_px();
  inline void set_has_py();
  inline void clear_has_py();
  inline void set_has_pz();
  inline void clear_has_pz();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_trkiso03();
  inline void clear_has_trkiso03();
  inline void set_has_ecaliso03();
  inline void clear_has_ecaliso03();
  inline void set_has_hcaliso03();
  inline void clear_has_hcaliso03();
  inline void set_has_isgoodglobalmuon();
  inline void clear_has_isgoodglobalmuon();
  inline void set_has_pfchargedhadroniso();
  inline void clear_has_pfchargedhadroniso();
  inline void set_has_pfneutralhadroniso();
  inline void clear_has_pfneutralhadroniso();
  inline void set_has_pfgammaiso();
  inline void clear_has_pfgammaiso();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_pt();
  inline void clear_has_pt();
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_trkhits();
  inline void clear_has_trkhits();
  inline void set_has_trkd0();
  inline void clear_has_trkd0();
  inline void set_has_trkd0error();
  inline void clear_has_trkd0error();
  inline void set_has_trkdz();
  inline void clear_has_trkdz();
  inline void set_has_trkdzerror();
  inline void clear_has_trkdzerror();
  inline void set_has_globalchi2();
  inline void clear_has_globalchi2();
  inline void set_has_trkiso();
  inline void clear_has_trkiso();
  inline void set_has_ecaliso();
  inline void clear_has_ecaliso();
  inline void set_has_hcaliso();
  inline void clear_has_hcaliso();
  inline void set_has_hoiso();
  inline void clear_has_hoiso();
  inline void set_has_vtxindex();
  inline void clear_has_vtxindex();
  inline void set_has_vtxdistxy();
  inline void clear_has_vtxdistxy();
  inline void set_has_vtxdistz();
  inline void clear_has_vtxdistz();
  inline void set_has_cocktaileta();
  inline void clear_has_cocktaileta();
  inline void set_has_cocktailphi();
  inline void clear_has_cocktailphi();
  inline void set_has_cocktailpt();
  inline void clear_has_cocktailpt();
  inline void set_has_cocktailp();
  inline void clear_has_cocktailp();
  inline void set_has_cocktailcharge();
  inline void clear_has_cocktailcharge();
  inline void set_has_cocktailtrkhits();
  inline void clear_has_cocktailtrkhits();
  inline void set_has_cocktailtrkd0();
  inline void clear_has_cocktailtrkd0();
  inline void set_has_cocktailtrkd0error();
  inline void clear_has_cocktailtrkd0error();
  inline void set_has_cocktailtrkdz();
  inline void clear_has_cocktailtrkdz();
  inline void set_has_cocktailtrkdzerror();
  inline void clear_has_cocktailtrkdzerror();
  inline void set_has_cocktailglobalchi2();
  inline void clear_has_cocktailglobalchi2();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double energy_;
  double px_;
  double py_;
  double pz_;
  double mass_;
  double trkiso03_;
  ::google::protobuf::int32 charge_;
  ::google::protobuf::int32 isgoodglobalmuon_;
  double ecaliso03_;
  double hcaliso03_;
  double pfchargedhadroniso_;
  double pfneutralhadroniso_;
  double pfgammaiso_;
  double eta_;
  double phi_;
  double pt_;
  double p_;
  double trkd0_;
  double trkd0error_;
  double trkdz_;
  double trkdzerror_;
  ::google::protobuf::int32 trkhits_;
  ::google::protobuf::int32 vtxindex_;
  double globalchi2_;
  double trkiso_;
  double ecaliso_;
  double hcaliso_;
  double hoiso_;
  double vtxdistxy_;
  double vtxdistz_;
  double cocktaileta_;
  double cocktailphi_;
  double cocktailpt_;
  double cocktailp_;
  ::google::protobuf::int32 cocktailcharge_;
  ::google::protobuf::int32 cocktailtrkhits_;
  double cocktailtrkd0_;
  double cocktailtrkd0error_;
  double cocktailtrkdz_;
  double cocktailtrkdzerror_;
  double cocktailglobalchi2_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(42 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Muon* default_instance_;
};
// -------------------------------------------------------------------

class MET : public ::google::protobuf::Message {
 public:
  MET();
  virtual ~MET();
  
  MET(const MET& from);
  
  inline MET& operator=(const MET& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MET& default_instance();
  
  void Swap(MET* other);
  
  // implements Message ----------------------------------------------
  
  MET* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MET& from);
  void MergeFrom(const MET& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MET_METAlgorithm METAlgorithm;
  static const METAlgorithm Calo = MET_METAlgorithm_Calo;
  static const METAlgorithm ParticleFlow = MET_METAlgorithm_ParticleFlow;
  static inline bool METAlgorithm_IsValid(int value) {
    return MET_METAlgorithm_IsValid(value);
  }
  static const METAlgorithm METAlgorithm_MIN =
    MET_METAlgorithm_METAlgorithm_MIN;
  static const METAlgorithm METAlgorithm_MAX =
    MET_METAlgorithm_METAlgorithm_MAX;
  static const int METAlgorithm_ARRAYSIZE =
    MET_METAlgorithm_METAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  METAlgorithm_descriptor() {
    return MET_METAlgorithm_descriptor();
  }
  static inline const ::std::string& METAlgorithm_Name(METAlgorithm value) {
    return MET_METAlgorithm_Name(value);
  }
  static inline bool METAlgorithm_Parse(const ::std::string& name,
      METAlgorithm* value) {
    return MET_METAlgorithm_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional double Ex = 1 [default = 0];
  inline bool has_ex() const;
  inline void clear_ex();
  static const int kExFieldNumber = 1;
  inline double ex() const;
  inline void set_ex(double value);
  
  // optional double Ey = 2 [default = 0];
  inline bool has_ey() const;
  inline void clear_ey();
  static const int kEyFieldNumber = 2;
  inline double ey() const;
  inline void set_ey(double value);
  
  // optional double ET = 3 [default = 0];
  inline bool has_et() const;
  inline void clear_et();
  static const int kETFieldNumber = 3;
  inline double et() const;
  inline void set_et(double value);
  
  // optional double Phi = 4 [default = 0];
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 4;
  inline double phi() const;
  inline void set_phi(double value);
  
  // optional double SumET = 5 [default = 0];
  inline bool has_sumet() const;
  inline void clear_sumet();
  static const int kSumETFieldNumber = 5;
  inline double sumet() const;
  inline void set_sumet(double value);
  
  // optional double Significance = 6 [default = 0];
  inline bool has_significance() const;
  inline void clear_significance();
  static const int kSignificanceFieldNumber = 6;
  inline double significance() const;
  inline void set_significance(double value);
  
  // optional double ETUncorr = 7 [default = 0];
  inline bool has_etuncorr() const;
  inline void clear_etuncorr();
  static const int kETUncorrFieldNumber = 7;
  inline double etuncorr() const;
  inline void set_etuncorr(double value);
  
  // optional double PhiUncorr = 8 [default = 0];
  inline bool has_phiuncorr() const;
  inline void clear_phiuncorr();
  static const int kPhiUncorrFieldNumber = 8;
  inline double phiuncorr() const;
  inline void set_phiuncorr(double value);
  
  // optional double SumETUncorr = 9 [default = 0];
  inline bool has_sumetuncorr() const;
  inline void clear_sumetuncorr();
  static const int kSumETUncorrFieldNumber = 9;
  inline double sumetuncorr() const;
  inline void set_sumetuncorr(double value);
  
  // optional .HEP.MET.METAlgorithm type = 10 [default = ParticleFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::HEP::MET_METAlgorithm type() const;
  inline void set_type(::HEP::MET_METAlgorithm value);
  
  // @@protoc_insertion_point(class_scope:HEP.MET)
 private:
  inline void set_has_ex();
  inline void clear_has_ex();
  inline void set_has_ey();
  inline void clear_has_ey();
  inline void set_has_et();
  inline void clear_has_et();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_sumet();
  inline void clear_has_sumet();
  inline void set_has_significance();
  inline void clear_has_significance();
  inline void set_has_etuncorr();
  inline void clear_has_etuncorr();
  inline void set_has_phiuncorr();
  inline void clear_has_phiuncorr();
  inline void set_has_sumetuncorr();
  inline void clear_has_sumetuncorr();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double ex_;
  double ey_;
  double et_;
  double phi_;
  double sumet_;
  double significance_;
  double etuncorr_;
  double phiuncorr_;
  double sumetuncorr_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static MET* default_instance_;
};
// -------------------------------------------------------------------

class Vertex : public ::google::protobuf::Message {
 public:
  Vertex();
  virtual ~Vertex();
  
  Vertex(const Vertex& from);
  
  inline Vertex& operator=(const Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vertex& default_instance();
  
  void Swap(Vertex* other);
  
  // implements Message ----------------------------------------------
  
  Vertex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vertex& from);
  void MergeFrom(const Vertex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double X = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);
  
  // optional double Y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);
  
  // optional double Z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);
  
  // optional double XErr = 4 [default = 0];
  inline bool has_xerr() const;
  inline void clear_xerr();
  static const int kXErrFieldNumber = 4;
  inline double xerr() const;
  inline void set_xerr(double value);
  
  // optional double YErr = 5 [default = 0];
  inline bool has_yerr() const;
  inline void clear_yerr();
  static const int kYErrFieldNumber = 5;
  inline double yerr() const;
  inline void set_yerr(double value);
  
  // optional double ZErr = 6 [default = 0];
  inline bool has_zerr() const;
  inline void clear_zerr();
  static const int kZErrFieldNumber = 6;
  inline double zerr() const;
  inline void set_zerr(double value);
  
  // optional double Rho = 7 [default = 0];
  inline bool has_rho() const;
  inline void clear_rho();
  static const int kRhoFieldNumber = 7;
  inline double rho() const;
  inline void set_rho(double value);
  
  // optional double Chi2 = 8 [default = 0];
  inline bool has_chi2() const;
  inline void clear_chi2();
  static const int kChi2FieldNumber = 8;
  inline double chi2() const;
  inline void set_chi2(double value);
  
  // optional double NDF = 9 [default = 0];
  inline bool has_ndf() const;
  inline void clear_ndf();
  static const int kNDFFieldNumber = 9;
  inline double ndf() const;
  inline void set_ndf(double value);
  
  // optional int32 NTracks = 10 [default = 0];
  inline bool has_ntracks() const;
  inline void clear_ntracks();
  static const int kNTracksFieldNumber = 10;
  inline ::google::protobuf::int32 ntracks() const;
  inline void set_ntracks(::google::protobuf::int32 value);
  
  // optional int32 NTracksW05 = 11 [default = 0];
  inline bool has_ntracksw05() const;
  inline void clear_ntracksw05();
  static const int kNTracksW05FieldNumber = 11;
  inline ::google::protobuf::int32 ntracksw05() const;
  inline void set_ntracksw05(::google::protobuf::int32 value);
  
  // optional int32 IsFake = 12 [default = 0];
  inline bool has_isfake() const;
  inline void clear_isfake();
  static const int kIsFakeFieldNumber = 12;
  inline ::google::protobuf::int32 isfake() const;
  inline void set_isfake(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:HEP.Vertex)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_xerr();
  inline void clear_has_xerr();
  inline void set_has_yerr();
  inline void clear_has_yerr();
  inline void set_has_zerr();
  inline void clear_has_zerr();
  inline void set_has_rho();
  inline void clear_has_rho();
  inline void set_has_chi2();
  inline void clear_has_chi2();
  inline void set_has_ndf();
  inline void clear_has_ndf();
  inline void set_has_ntracks();
  inline void clear_has_ntracks();
  inline void set_has_ntracksw05();
  inline void clear_has_ntracksw05();
  inline void set_has_isfake();
  inline void clear_has_isfake();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double x_;
  double y_;
  double z_;
  double xerr_;
  double yerr_;
  double zerr_;
  double rho_;
  double chi2_;
  double ndf_;
  ::google::protobuf::int32 ntracks_;
  ::google::protobuf::int32 ntracksw05_;
  ::google::protobuf::int32 isfake_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Vertex* default_instance_;
};
// -------------------------------------------------------------------

class BeamSpot : public ::google::protobuf::Message {
 public:
  BeamSpot();
  virtual ~BeamSpot();
  
  BeamSpot(const BeamSpot& from);
  
  inline BeamSpot& operator=(const BeamSpot& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BeamSpot& default_instance();
  
  void Swap(BeamSpot* other);
  
  // implements Message ----------------------------------------------
  
  BeamSpot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BeamSpot& from);
  void MergeFrom(const BeamSpot& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double WidthX = 1 [default = 0];
  inline bool has_widthx() const;
  inline void clear_widthx();
  static const int kWidthXFieldNumber = 1;
  inline double widthx() const;
  inline void set_widthx(double value);
  
  // optional double WidthXError = 2 [default = 0];
  inline bool has_widthxerror() const;
  inline void clear_widthxerror();
  static const int kWidthXErrorFieldNumber = 2;
  inline double widthxerror() const;
  inline void set_widthxerror(double value);
  
  // optional double WidthY = 3 [default = 0];
  inline bool has_widthy() const;
  inline void clear_widthy();
  static const int kWidthYFieldNumber = 3;
  inline double widthy() const;
  inline void set_widthy(double value);
  
  // optional double WidthYError = 4 [default = 0];
  inline bool has_widthyerror() const;
  inline void clear_widthyerror();
  static const int kWidthYErrorFieldNumber = 4;
  inline double widthyerror() const;
  inline void set_widthyerror(double value);
  
  // optional double X0 = 5 [default = 0];
  inline bool has_x0() const;
  inline void clear_x0();
  static const int kX0FieldNumber = 5;
  inline double x0() const;
  inline void set_x0(double value);
  
  // optional double X0Error = 6 [default = 0];
  inline bool has_x0error() const;
  inline void clear_x0error();
  static const int kX0ErrorFieldNumber = 6;
  inline double x0error() const;
  inline void set_x0error(double value);
  
  // optional double Y0 = 7 [default = 0];
  inline bool has_y0() const;
  inline void clear_y0();
  static const int kY0FieldNumber = 7;
  inline double y0() const;
  inline void set_y0(double value);
  
  // optional double Y0Error = 8 [default = 0];
  inline bool has_y0error() const;
  inline void clear_y0error();
  static const int kY0ErrorFieldNumber = 8;
  inline double y0error() const;
  inline void set_y0error(double value);
  
  // optional double Z0 = 9 [default = 0];
  inline bool has_z0() const;
  inline void clear_z0();
  static const int kZ0FieldNumber = 9;
  inline double z0() const;
  inline void set_z0(double value);
  
  // optional double Z0Error = 10 [default = 0];
  inline bool has_z0error() const;
  inline void clear_z0error();
  static const int kZ0ErrorFieldNumber = 10;
  inline double z0error() const;
  inline void set_z0error(double value);
  
  // optional double dxdz = 11 [default = 0];
  inline bool has_dxdz() const;
  inline void clear_dxdz();
  static const int kDxdzFieldNumber = 11;
  inline double dxdz() const;
  inline void set_dxdz(double value);
  
  // optional double dxdzError = 12 [default = 0];
  inline bool has_dxdzerror() const;
  inline void clear_dxdzerror();
  static const int kDxdzErrorFieldNumber = 12;
  inline double dxdzerror() const;
  inline void set_dxdzerror(double value);
  
  // optional double dydz = 13 [default = 0];
  inline bool has_dydz() const;
  inline void clear_dydz();
  static const int kDydzFieldNumber = 13;
  inline double dydz() const;
  inline void set_dydz(double value);
  
  // optional double dydzError = 14 [default = 0];
  inline bool has_dydzerror() const;
  inline void clear_dydzerror();
  static const int kDydzErrorFieldNumber = 14;
  inline double dydzerror() const;
  inline void set_dydzerror(double value);
  
  // optional double sigmaZ = 15 [default = 0];
  inline bool has_sigmaz() const;
  inline void clear_sigmaz();
  static const int kSigmaZFieldNumber = 15;
  inline double sigmaz() const;
  inline void set_sigmaz(double value);
  
  // optional double sigmaZError = 16 [default = 0];
  inline bool has_sigmazerror() const;
  inline void clear_sigmazerror();
  static const int kSigmaZErrorFieldNumber = 16;
  inline double sigmazerror() const;
  inline void set_sigmazerror(double value);
  
  // @@protoc_insertion_point(class_scope:HEP.BeamSpot)
 private:
  inline void set_has_widthx();
  inline void clear_has_widthx();
  inline void set_has_widthxerror();
  inline void clear_has_widthxerror();
  inline void set_has_widthy();
  inline void clear_has_widthy();
  inline void set_has_widthyerror();
  inline void clear_has_widthyerror();
  inline void set_has_x0();
  inline void clear_has_x0();
  inline void set_has_x0error();
  inline void clear_has_x0error();
  inline void set_has_y0();
  inline void clear_has_y0();
  inline void set_has_y0error();
  inline void clear_has_y0error();
  inline void set_has_z0();
  inline void clear_has_z0();
  inline void set_has_z0error();
  inline void clear_has_z0error();
  inline void set_has_dxdz();
  inline void clear_has_dxdz();
  inline void set_has_dxdzerror();
  inline void clear_has_dxdzerror();
  inline void set_has_dydz();
  inline void clear_has_dydz();
  inline void set_has_dydzerror();
  inline void clear_has_dydzerror();
  inline void set_has_sigmaz();
  inline void clear_has_sigmaz();
  inline void set_has_sigmazerror();
  inline void clear_has_sigmazerror();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double widthx_;
  double widthxerror_;
  double widthy_;
  double widthyerror_;
  double x0_;
  double x0error_;
  double y0_;
  double y0error_;
  double z0_;
  double z0error_;
  double dxdz_;
  double dxdzerror_;
  double dydz_;
  double dydzerror_;
  double sigmaz_;
  double sigmazerror_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static BeamSpot* default_instance_;
};
// -------------------------------------------------------------------

class Trigger : public ::google::protobuf::Message {
 public:
  Trigger();
  virtual ~Trigger();
  
  Trigger(const Trigger& from);
  
  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trigger& default_instance();
  
  void Swap(Trigger* other);
  
  // implements Message ----------------------------------------------
  
  Trigger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 L1PhysBits = 1;
  inline int l1physbits_size() const;
  inline void clear_l1physbits();
  static const int kL1PhysBitsFieldNumber = 1;
  inline ::google::protobuf::int32 l1physbits(int index) const;
  inline void set_l1physbits(int index, ::google::protobuf::int32 value);
  inline void add_l1physbits(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      l1physbits() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_l1physbits();
  
  // repeated int32 L1TechBits = 2;
  inline int l1techbits_size() const;
  inline void clear_l1techbits();
  static const int kL1TechBitsFieldNumber = 2;
  inline ::google::protobuf::int32 l1techbits(int index) const;
  inline void set_l1techbits(int index, ::google::protobuf::int32 value);
  inline void add_l1techbits(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      l1techbits() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_l1techbits();
  
  // repeated int32 HLTBits = 3;
  inline int hltbits_size() const;
  inline void clear_hltbits();
  static const int kHLTBitsFieldNumber = 3;
  inline ::google::protobuf::int32 hltbits(int index) const;
  inline void set_hltbits(int index, ::google::protobuf::int32 value);
  inline void add_hltbits(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hltbits() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hltbits();
  
  // repeated int32 HLTResults = 4;
  inline int hltresults_size() const;
  inline void clear_hltresults();
  static const int kHLTResultsFieldNumber = 4;
  inline ::google::protobuf::int32 hltresults(int index) const;
  inline void set_hltresults(int index, ::google::protobuf::int32 value);
  inline void add_hltresults(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hltresults() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hltresults();
  
  // repeated int32 HLTResultsOther = 5;
  inline int hltresultsother_size() const;
  inline void clear_hltresultsother();
  static const int kHLTResultsOtherFieldNumber = 5;
  inline ::google::protobuf::int32 hltresultsother(int index) const;
  inline void set_hltresultsother(int index, ::google::protobuf::int32 value);
  inline void add_hltresultsother(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hltresultsother() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hltresultsother();
  
  // repeated int32 HLTPrescales = 6;
  inline int hltprescales_size() const;
  inline void clear_hltprescales();
  static const int kHLTPrescalesFieldNumber = 6;
  inline ::google::protobuf::int32 hltprescales(int index) const;
  inline void set_hltprescales(int index, ::google::protobuf::int32 value);
  inline void add_hltprescales(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hltprescales() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hltprescales();
  
  // repeated int32 HLTPrescalesOther = 7;
  inline int hltprescalesother_size() const;
  inline void clear_hltprescalesother();
  static const int kHLTPrescalesOtherFieldNumber = 7;
  inline ::google::protobuf::int32 hltprescalesother(int index) const;
  inline void set_hltprescalesother(int index, ::google::protobuf::int32 value);
  inline void add_hltprescalesother(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hltprescalesother() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hltprescalesother();
  
  // repeated string HLTNames = 8;
  inline int hltnames_size() const;
  inline void clear_hltnames();
  static const int kHLTNamesFieldNumber = 8;
  inline const ::std::string& hltnames(int index) const;
  inline ::std::string* mutable_hltnames(int index);
  inline void set_hltnames(int index, const ::std::string& value);
  inline void set_hltnames(int index, const char* value);
  inline void set_hltnames(int index, const char* value, size_t size);
  inline ::std::string* add_hltnames();
  inline void add_hltnames(const ::std::string& value);
  inline void add_hltnames(const char* value);
  inline void add_hltnames(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hltnames() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hltnames();
  
  // @@protoc_insertion_point(class_scope:HEP.Trigger)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > l1physbits_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > l1techbits_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hltbits_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hltresults_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hltresultsother_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hltprescales_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hltprescalesother_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hltnames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Trigger* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();
  
  Event(const Event& from);
  
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();
  
  void Swap(Event* other);
  
  // implements Message ----------------------------------------------
  
  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .HEP.Jet goodPatJets = 1;
  inline int goodpatjets_size() const;
  inline void clear_goodpatjets();
  static const int kGoodPatJetsFieldNumber = 1;
  inline const ::HEP::Jet& goodpatjets(int index) const;
  inline ::HEP::Jet* mutable_goodpatjets(int index);
  inline ::HEP::Jet* add_goodpatjets();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Jet >&
      goodpatjets() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Jet >*
      mutable_goodpatjets();
  
  // repeated .HEP.Jet goodPatJetsPFlow = 2;
  inline int goodpatjetspflow_size() const;
  inline void clear_goodpatjetspflow();
  static const int kGoodPatJetsPFlowFieldNumber = 2;
  inline const ::HEP::Jet& goodpatjetspflow(int index) const;
  inline ::HEP::Jet* mutable_goodpatjetspflow(int index);
  inline ::HEP::Jet* add_goodpatjetspflow();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Jet >&
      goodpatjetspflow() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Jet >*
      mutable_goodpatjetspflow();
  
  // repeated .HEP.Jet goodPatJetsCA8PF = 3;
  inline int goodpatjetsca8pf_size() const;
  inline void clear_goodpatjetsca8pf();
  static const int kGoodPatJetsCA8PFFieldNumber = 3;
  inline const ::HEP::Jet& goodpatjetsca8pf(int index) const;
  inline ::HEP::Jet* mutable_goodpatjetsca8pf(int index);
  inline ::HEP::Jet* add_goodpatjetsca8pf();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Jet >&
      goodpatjetsca8pf() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Jet >*
      mutable_goodpatjetsca8pf();
  
  // repeated .HEP.Electron selectedPatElectrons = 4;
  inline int selectedpatelectrons_size() const;
  inline void clear_selectedpatelectrons();
  static const int kSelectedPatElectronsFieldNumber = 4;
  inline const ::HEP::Electron& selectedpatelectrons(int index) const;
  inline ::HEP::Electron* mutable_selectedpatelectrons(int index);
  inline ::HEP::Electron* add_selectedpatelectrons();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Electron >&
      selectedpatelectrons() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Electron >*
      mutable_selectedpatelectrons();
  
  // repeated .HEP.Electron selectedPatElectronsLoosePFlow = 5;
  inline int selectedpatelectronsloosepflow_size() const;
  inline void clear_selectedpatelectronsloosepflow();
  static const int kSelectedPatElectronsLoosePFlowFieldNumber = 5;
  inline const ::HEP::Electron& selectedpatelectronsloosepflow(int index) const;
  inline ::HEP::Electron* mutable_selectedpatelectronsloosepflow(int index);
  inline ::HEP::Electron* add_selectedpatelectronsloosepflow();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Electron >&
      selectedpatelectronsloosepflow() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Electron >*
      mutable_selectedpatelectronsloosepflow();
  
  // repeated .HEP.MET patMETs = 6;
  inline int patmets_size() const;
  inline void clear_patmets();
  static const int kPatMETsFieldNumber = 6;
  inline const ::HEP::MET& patmets(int index) const;
  inline ::HEP::MET* mutable_patmets(int index);
  inline ::HEP::MET* add_patmets();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::MET >&
      patmets() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::MET >*
      mutable_patmets();
  
  // repeated .HEP.MET patMETsPFlow = 7;
  inline int patmetspflow_size() const;
  inline void clear_patmetspflow();
  static const int kPatMETsPFlowFieldNumber = 7;
  inline const ::HEP::MET& patmetspflow(int index) const;
  inline ::HEP::MET* mutable_patmetspflow(int index);
  inline ::HEP::MET* add_patmetspflow();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::MET >&
      patmetspflow() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::MET >*
      mutable_patmetspflow();
  
  // repeated .HEP.Muon selectedPatMuons = 8;
  inline int selectedpatmuons_size() const;
  inline void clear_selectedpatmuons();
  static const int kSelectedPatMuonsFieldNumber = 8;
  inline const ::HEP::Muon& selectedpatmuons(int index) const;
  inline ::HEP::Muon* mutable_selectedpatmuons(int index);
  inline ::HEP::Muon* add_selectedpatmuons();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Muon >&
      selectedpatmuons() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Muon >*
      mutable_selectedpatmuons();
  
  // repeated .HEP.Muon selectedPatMuonsLoosePFlow = 9;
  inline int selectedpatmuonsloosepflow_size() const;
  inline void clear_selectedpatmuonsloosepflow();
  static const int kSelectedPatMuonsLoosePFlowFieldNumber = 9;
  inline const ::HEP::Muon& selectedpatmuonsloosepflow(int index) const;
  inline ::HEP::Muon* mutable_selectedpatmuonsloosepflow(int index);
  inline ::HEP::Muon* add_selectedpatmuonsloosepflow();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Muon >&
      selectedpatmuonsloosepflow() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Muon >*
      mutable_selectedpatmuonsloosepflow();
  
  // repeated .HEP.Vertex goodOfflinePrimaryVertices = 10;
  inline int goodofflineprimaryvertices_size() const;
  inline void clear_goodofflineprimaryvertices();
  static const int kGoodOfflinePrimaryVerticesFieldNumber = 10;
  inline const ::HEP::Vertex& goodofflineprimaryvertices(int index) const;
  inline ::HEP::Vertex* mutable_goodofflineprimaryvertices(int index);
  inline ::HEP::Vertex* add_goodofflineprimaryvertices();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Vertex >&
      goodofflineprimaryvertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Vertex >*
      mutable_goodofflineprimaryvertices();
  
  // repeated .HEP.BeamSpot beamSpot = 11;
  inline int beamspot_size() const;
  inline void clear_beamspot();
  static const int kBeamSpotFieldNumber = 11;
  inline const ::HEP::BeamSpot& beamspot(int index) const;
  inline ::HEP::BeamSpot* mutable_beamspot(int index);
  inline ::HEP::BeamSpot* add_beamspot();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::BeamSpot >&
      beamspot() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::BeamSpot >*
      mutable_beamspot();
  
  // optional double MagneticField = 12;
  inline bool has_magneticfield() const;
  inline void clear_magneticfield();
  static const int kMagneticFieldFieldNumber = 12;
  inline double magneticfield() const;
  inline void set_magneticfield(double value);
  
  // required uint32 Run = 13;
  inline bool has_run() const;
  inline void clear_run();
  static const int kRunFieldNumber = 13;
  inline ::google::protobuf::uint32 run() const;
  inline void set_run(::google::protobuf::uint32 value);
  
  // required uint32 Number = 14;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 14;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);
  
  // optional uint32 Bunch = 15;
  inline bool has_bunch() const;
  inline void clear_bunch();
  static const int kBunchFieldNumber = 15;
  inline ::google::protobuf::uint32 bunch() const;
  inline void set_bunch(::google::protobuf::uint32 value);
  
  // required uint32 LumiSection = 16;
  inline bool has_lumisection() const;
  inline void clear_lumisection();
  static const int kLumiSectionFieldNumber = 16;
  inline ::google::protobuf::uint32 lumisection() const;
  inline void set_lumisection(::google::protobuf::uint32 value);
  
  // optional uint32 Orbit = 17;
  inline bool has_orbit() const;
  inline void clear_orbit();
  static const int kOrbitFieldNumber = 17;
  inline ::google::protobuf::uint32 orbit() const;
  inline void set_orbit(::google::protobuf::uint32 value);
  
  // optional double Time = 18;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 18;
  inline double time() const;
  inline void set_time(double value);
  
  // optional bool isData = 19;
  inline bool has_isdata() const;
  inline void clear_isdata();
  static const int kIsDataFieldNumber = 19;
  inline bool isdata() const;
  inline void set_isdata(bool value);
  
  // optional double rho = 20;
  inline bool has_rho() const;
  inline void clear_rho();
  static const int kRhoFieldNumber = 20;
  inline double rho() const;
  inline void set_rho(double value);
  
  // repeated .HEP.Trigger trigger = 21;
  inline int trigger_size() const;
  inline void clear_trigger();
  static const int kTriggerFieldNumber = 21;
  inline const ::HEP::Trigger& trigger(int index) const;
  inline ::HEP::Trigger* mutable_trigger(int index);
  inline ::HEP::Trigger* add_trigger();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Trigger >&
      trigger() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Trigger >*
      mutable_trigger();
  
  // @@protoc_insertion_point(class_scope:HEP.Event)
 private:
  inline void set_has_magneticfield();
  inline void clear_has_magneticfield();
  inline void set_has_run();
  inline void clear_has_run();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_bunch();
  inline void clear_has_bunch();
  inline void set_has_lumisection();
  inline void clear_has_lumisection();
  inline void set_has_orbit();
  inline void clear_has_orbit();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_isdata();
  inline void clear_has_isdata();
  inline void set_has_rho();
  inline void clear_has_rho();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::HEP::Jet > goodpatjets_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Jet > goodpatjetspflow_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Jet > goodpatjetsca8pf_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Electron > selectedpatelectrons_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Electron > selectedpatelectronsloosepflow_;
  ::google::protobuf::RepeatedPtrField< ::HEP::MET > patmets_;
  ::google::protobuf::RepeatedPtrField< ::HEP::MET > patmetspflow_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Muon > selectedpatmuons_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Muon > selectedpatmuonsloosepflow_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Vertex > goodofflineprimaryvertices_;
  ::google::protobuf::RepeatedPtrField< ::HEP::BeamSpot > beamspot_;
  double magneticfield_;
  ::google::protobuf::uint32 run_;
  ::google::protobuf::uint32 number_;
  ::google::protobuf::uint32 bunch_;
  ::google::protobuf::uint32 lumisection_;
  double time_;
  ::google::protobuf::uint32 orbit_;
  bool isdata_;
  double rho_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Trigger > trigger_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class GenEvent : public ::google::protobuf::Message {
 public:
  GenEvent();
  virtual ~GenEvent();
  
  GenEvent(const GenEvent& from);
  
  inline GenEvent& operator=(const GenEvent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenEvent& default_instance();
  
  void Swap(GenEvent* other);
  
  // implements Message ----------------------------------------------
  
  GenEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenEvent& from);
  void MergeFrom(const GenEvent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 ProcessID = 1;
  inline bool has_processid() const;
  inline void clear_processid();
  static const int kProcessIDFieldNumber = 1;
  inline ::google::protobuf::uint32 processid() const;
  inline void set_processid(::google::protobuf::uint32 value);
  
  // optional double PtHat = 2;
  inline bool has_pthat() const;
  inline void clear_pthat();
  static const int kPtHatFieldNumber = 2;
  inline double pthat() const;
  inline void set_pthat(double value);
  
  // repeated double PDFWeights = 3;
  inline int pdfweights_size() const;
  inline void clear_pdfweights();
  static const int kPDFWeightsFieldNumber = 3;
  inline double pdfweights(int index) const;
  inline void set_pdfweights(int index, double value);
  inline void add_pdfweights(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pdfweights() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pdfweights();
  
  // repeated int32 PileUpInteractions = 4;
  inline int pileupinteractions_size() const;
  inline void clear_pileupinteractions();
  static const int kPileUpInteractionsFieldNumber = 4;
  inline ::google::protobuf::int32 pileupinteractions(int index) const;
  inline void set_pileupinteractions(int index, ::google::protobuf::int32 value);
  inline void add_pileupinteractions(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pileupinteractions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pileupinteractions();
  
  // repeated int32 PileUpOriginBX = 5;
  inline int pileuporiginbx_size() const;
  inline void clear_pileuporiginbx();
  static const int kPileUpOriginBXFieldNumber = 5;
  inline ::google::protobuf::int32 pileuporiginbx(int index) const;
  inline void set_pileuporiginbx(int index, ::google::protobuf::int32 value);
  inline void add_pileuporiginbx(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pileuporiginbx() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pileuporiginbx();
  
  // repeated double GenMETExTrue = 6;
  inline int genmetextrue_size() const;
  inline void clear_genmetextrue();
  static const int kGenMETExTrueFieldNumber = 6;
  inline double genmetextrue(int index) const;
  inline void set_genmetextrue(int index, double value);
  inline void add_genmetextrue(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      genmetextrue() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_genmetextrue();
  
  // repeated double GenMETEyTrue = 7;
  inline int genmeteytrue_size() const;
  inline void clear_genmeteytrue();
  static const int kGenMETEyTrueFieldNumber = 7;
  inline double genmeteytrue(int index) const;
  inline void set_genmeteytrue(int index, double value);
  inline void add_genmeteytrue(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      genmeteytrue() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_genmeteytrue();
  
  // repeated .HEP.GenJet genJets = 8;
  inline int genjets_size() const;
  inline void clear_genjets();
  static const int kGenJetsFieldNumber = 8;
  inline const ::HEP::GenJet& genjets(int index) const;
  inline ::HEP::GenJet* mutable_genjets(int index);
  inline ::HEP::GenJet* add_genjets();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::GenJet >&
      genjets() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::GenJet >*
      mutable_genjets();
  
  // repeated .HEP.GenParticle genParticles = 9;
  inline int genparticles_size() const;
  inline void clear_genparticles();
  static const int kGenParticlesFieldNumber = 9;
  inline const ::HEP::GenParticle& genparticles(int index) const;
  inline ::HEP::GenParticle* mutable_genparticles(int index);
  inline ::HEP::GenParticle* add_genparticles();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::GenParticle >&
      genparticles() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::GenParticle >*
      mutable_genparticles();
  
  // @@protoc_insertion_point(class_scope:HEP.GenEvent)
 private:
  inline void set_has_processid();
  inline void clear_has_processid();
  inline void set_has_pthat();
  inline void clear_has_pthat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double pthat_;
  ::google::protobuf::RepeatedField< double > pdfweights_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pileupinteractions_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pileuporiginbx_;
  ::google::protobuf::RepeatedField< double > genmetextrue_;
  ::google::protobuf::RepeatedField< double > genmeteytrue_;
  ::google::protobuf::RepeatedPtrField< ::HEP::GenJet > genjets_;
  ::google::protobuf::RepeatedPtrField< ::HEP::GenParticle > genparticles_;
  ::google::protobuf::uint32 processid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static GenEvent* default_instance_;
};
// -------------------------------------------------------------------

class EventCollection : public ::google::protobuf::Message {
 public:
  EventCollection();
  virtual ~EventCollection();
  
  EventCollection(const EventCollection& from);
  
  inline EventCollection& operator=(const EventCollection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventCollection& default_instance();
  
  void Swap(EventCollection* other);
  
  // implements Message ----------------------------------------------
  
  EventCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventCollection& from);
  void MergeFrom(const EventCollection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .HEP.Event event = 1;
  inline int event_size() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline const ::HEP::Event& event(int index) const;
  inline ::HEP::Event* mutable_event(int index);
  inline ::HEP::Event* add_event();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Event >&
      event() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Event >*
      mutable_event();
  
  // repeated .HEP.GenEvent genEvent = 2;
  inline int genevent_size() const;
  inline void clear_genevent();
  static const int kGenEventFieldNumber = 2;
  inline const ::HEP::GenEvent& genevent(int index) const;
  inline ::HEP::GenEvent* mutable_genevent(int index);
  inline ::HEP::GenEvent* add_genevent();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::GenEvent >&
      genevent() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::GenEvent >*
      mutable_genevent();
  
  // @@protoc_insertion_point(class_scope:HEP.EventCollection)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::HEP::Event > event_;
  ::google::protobuf::RepeatedPtrField< ::HEP::GenEvent > genevent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static EventCollection* default_instance_;
};
// ===================================================================


// ===================================================================

// Jet

// optional double Energy = 1 [default = 0];
inline bool Jet::has_energy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Jet::set_has_energy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Jet::clear_has_energy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Jet::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline double Jet::energy() const {
  return energy_;
}
inline void Jet::set_energy(double value) {
  set_has_energy();
  energy_ = value;
}

// optional double Px = 2 [default = 0];
inline bool Jet::has_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Jet::set_has_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Jet::clear_has_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Jet::clear_px() {
  px_ = 0;
  clear_has_px();
}
inline double Jet::px() const {
  return px_;
}
inline void Jet::set_px(double value) {
  set_has_px();
  px_ = value;
}

// optional double Py = 3 [default = 0];
inline bool Jet::has_py() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Jet::set_has_py() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Jet::clear_has_py() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Jet::clear_py() {
  py_ = 0;
  clear_has_py();
}
inline double Jet::py() const {
  return py_;
}
inline void Jet::set_py(double value) {
  set_has_py();
  py_ = value;
}

// optional double Pz = 4 [default = 0];
inline bool Jet::has_pz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Jet::set_has_pz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Jet::clear_has_pz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Jet::clear_pz() {
  pz_ = 0;
  clear_has_pz();
}
inline double Jet::pz() const {
  return pz_;
}
inline void Jet::set_pz(double value) {
  set_has_pz();
  pz_ = value;
}

// optional double Charge = 5 [default = 0];
inline bool Jet::has_charge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Jet::set_has_charge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Jet::clear_has_charge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Jet::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline double Jet::charge() const {
  return charge_;
}
inline void Jet::set_charge(double value) {
  set_has_charge();
  charge_ = value;
}

// optional double Mass = 6 [default = 0];
inline bool Jet::has_mass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Jet::set_has_mass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Jet::clear_has_mass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Jet::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double Jet::mass() const {
  return mass_;
}
inline void Jet::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// optional .HEP.Jet.JetAlgorithm type = 7 [default = PF2PAT];
inline bool Jet::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Jet::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Jet::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Jet::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::HEP::Jet_JetAlgorithm Jet::type() const {
  return static_cast< ::HEP::Jet_JetAlgorithm >(type_);
}
inline void Jet::set_type(::HEP::Jet_JetAlgorithm value) {
  GOOGLE_DCHECK(::HEP::Jet_JetAlgorithm_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double Eta = 8 [default = 0];
inline bool Jet::has_eta() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Jet::set_has_eta() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Jet::clear_has_eta() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Jet::clear_eta() {
  eta_ = 0;
  clear_has_eta();
}
inline double Jet::eta() const {
  return eta_;
}
inline void Jet::set_eta(double value) {
  set_has_eta();
  eta_ = value;
}

// optional double Phi = 9 [default = 0];
inline bool Jet::has_phi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Jet::set_has_phi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Jet::clear_has_phi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Jet::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double Jet::phi() const {
  return phi_;
}
inline void Jet::set_phi(double value) {
  set_has_phi();
  phi_ = value;
}

// optional double Pt = 10 [default = 0];
inline bool Jet::has_pt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Jet::set_has_pt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Jet::clear_has_pt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Jet::clear_pt() {
  pt_ = 0;
  clear_has_pt();
}
inline double Jet::pt() const {
  return pt_;
}
inline void Jet::set_pt(double value) {
  set_has_pt();
  pt_ = value;
}

// optional double PtRaw = 11 [default = 0];
inline bool Jet::has_ptraw() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Jet::set_has_ptraw() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Jet::clear_has_ptraw() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Jet::clear_ptraw() {
  ptraw_ = 0;
  clear_has_ptraw();
}
inline double Jet::ptraw() const {
  return ptraw_;
}
inline void Jet::set_ptraw(double value) {
  set_has_ptraw();
  ptraw_ = value;
}

// optional double EnergyRaw = 12 [default = 0];
inline bool Jet::has_energyraw() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Jet::set_has_energyraw() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Jet::clear_has_energyraw() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Jet::clear_energyraw() {
  energyraw_ = 0;
  clear_has_energyraw();
}
inline double Jet::energyraw() const {
  return energyraw_;
}
inline void Jet::set_energyraw(double value) {
  set_has_energyraw();
  energyraw_ = value;
}

// optional int32 PartonFlavour = 13 [default = 0];
inline bool Jet::has_partonflavour() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Jet::set_has_partonflavour() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Jet::clear_has_partonflavour() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Jet::clear_partonflavour() {
  partonflavour_ = 0;
  clear_has_partonflavour();
}
inline ::google::protobuf::int32 Jet::partonflavour() const {
  return partonflavour_;
}
inline void Jet::set_partonflavour(::google::protobuf::int32 value) {
  set_has_partonflavour();
  partonflavour_ = value;
}

// optional double JECUnc = 14 [default = 0];
inline bool Jet::has_jecunc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Jet::set_has_jecunc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Jet::clear_has_jecunc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Jet::clear_jecunc() {
  jecunc_ = 0;
  clear_has_jecunc();
}
inline double Jet::jecunc() const {
  return jecunc_;
}
inline void Jet::set_jecunc(double value) {
  set_has_jecunc();
  jecunc_ = value;
}

// optional double L2L3ResJEC = 15 [default = 0];
inline bool Jet::has_l2l3resjec() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Jet::set_has_l2l3resjec() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Jet::clear_has_l2l3resjec() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Jet::clear_l2l3resjec() {
  l2l3resjec_ = 0;
  clear_has_l2l3resjec();
}
inline double Jet::l2l3resjec() const {
  return l2l3resjec_;
}
inline void Jet::set_l2l3resjec(double value) {
  set_has_l2l3resjec();
  l2l3resjec_ = value;
}

// optional double L3AbsJEC = 16 [default = 0];
inline bool Jet::has_l3absjec() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Jet::set_has_l3absjec() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Jet::clear_has_l3absjec() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Jet::clear_l3absjec() {
  l3absjec_ = 0;
  clear_has_l3absjec();
}
inline double Jet::l3absjec() const {
  return l3absjec_;
}
inline void Jet::set_l3absjec(double value) {
  set_has_l3absjec();
  l3absjec_ = value;
}

// optional double L2RelJEC = 17 [default = 0];
inline bool Jet::has_l2reljec() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Jet::set_has_l2reljec() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Jet::clear_has_l2reljec() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Jet::clear_l2reljec() {
  l2reljec_ = 0;
  clear_has_l2reljec();
}
inline double Jet::l2reljec() const {
  return l2reljec_;
}
inline void Jet::set_l2reljec(double value) {
  set_has_l2reljec();
  l2reljec_ = value;
}

// optional double L1OffJEC = 18 [default = 0];
inline bool Jet::has_l1offjec() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Jet::set_has_l1offjec() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Jet::clear_has_l1offjec() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Jet::clear_l1offjec() {
  l1offjec_ = 0;
  clear_has_l1offjec();
}
inline double Jet::l1offjec() const {
  return l1offjec_;
}
inline void Jet::set_l1offjec(double value) {
  set_has_l1offjec();
  l1offjec_ = value;
}

// optional double EMF = 19 [default = 0];
inline bool Jet::has_emf() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Jet::set_has_emf() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Jet::clear_has_emf() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Jet::clear_emf() {
  emf_ = 0;
  clear_has_emf();
}
inline double Jet::emf() const {
  return emf_;
}
inline void Jet::set_emf(double value) {
  set_has_emf();
  emf_ = value;
}

// optional double resEMF = 20 [default = 0];
inline bool Jet::has_resemf() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Jet::set_has_resemf() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Jet::clear_has_resemf() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Jet::clear_resemf() {
  resemf_ = 0;
  clear_has_resemf();
}
inline double Jet::resemf() const {
  return resemf_;
}
inline void Jet::set_resemf(double value) {
  set_has_resemf();
  resemf_ = value;
}

// optional double HADF = 21 [default = 0];
inline bool Jet::has_hadf() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Jet::set_has_hadf() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Jet::clear_has_hadf() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Jet::clear_hadf() {
  hadf_ = 0;
  clear_has_hadf();
}
inline double Jet::hadf() const {
  return hadf_;
}
inline void Jet::set_hadf(double value) {
  set_has_hadf();
  hadf_ = value;
}

// optional int32 n90Hits = 22 [default = 0];
inline bool Jet::has_n90hits() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Jet::set_has_n90hits() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Jet::clear_has_n90hits() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Jet::clear_n90hits() {
  n90hits_ = 0;
  clear_has_n90hits();
}
inline ::google::protobuf::int32 Jet::n90hits() const {
  return n90hits_;
}
inline void Jet::set_n90hits(::google::protobuf::int32 value) {
  set_has_n90hits();
  n90hits_ = value;
}

// optional double fHPD = 23 [default = 0];
inline bool Jet::has_fhpd() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Jet::set_has_fhpd() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Jet::clear_has_fhpd() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Jet::clear_fhpd() {
  fhpd_ = 0;
  clear_has_fhpd();
}
inline double Jet::fhpd() const {
  return fhpd_;
}
inline void Jet::set_fhpd(double value) {
  set_has_fhpd();
  fhpd_ = value;
}

// optional double fRBX = 24 [default = 0];
inline bool Jet::has_frbx() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Jet::set_has_frbx() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Jet::clear_has_frbx() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Jet::clear_frbx() {
  frbx_ = 0;
  clear_has_frbx();
}
inline double Jet::frbx() const {
  return frbx_;
}
inline void Jet::set_frbx(double value) {
  set_has_frbx();
  frbx_ = value;
}

// optional double SigmaEta = 25 [default = 0];
inline bool Jet::has_sigmaeta() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Jet::set_has_sigmaeta() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Jet::clear_has_sigmaeta() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Jet::clear_sigmaeta() {
  sigmaeta_ = 0;
  clear_has_sigmaeta();
}
inline double Jet::sigmaeta() const {
  return sigmaeta_;
}
inline void Jet::set_sigmaeta(double value) {
  set_has_sigmaeta();
  sigmaeta_ = value;
}

// optional double SigmaPhi = 26 [default = 0];
inline bool Jet::has_sigmaphi() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Jet::set_has_sigmaphi() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Jet::clear_has_sigmaphi() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Jet::clear_sigmaphi() {
  sigmaphi_ = 0;
  clear_has_sigmaphi();
}
inline double Jet::sigmaphi() const {
  return sigmaphi_;
}
inline void Jet::set_sigmaphi(double value) {
  set_has_sigmaphi();
  sigmaphi_ = value;
}

// optional double TrackCountingHighEffBTag = 27 [default = 0];
inline bool Jet::has_trackcountinghigheffbtag() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Jet::set_has_trackcountinghigheffbtag() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Jet::clear_has_trackcountinghigheffbtag() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Jet::clear_trackcountinghigheffbtag() {
  trackcountinghigheffbtag_ = 0;
  clear_has_trackcountinghigheffbtag();
}
inline double Jet::trackcountinghigheffbtag() const {
  return trackcountinghigheffbtag_;
}
inline void Jet::set_trackcountinghigheffbtag(double value) {
  set_has_trackcountinghigheffbtag();
  trackcountinghigheffbtag_ = value;
}

// optional double TrackCountingHighPurBTag = 28 [default = 0];
inline bool Jet::has_trackcountinghighpurbtag() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Jet::set_has_trackcountinghighpurbtag() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Jet::clear_has_trackcountinghighpurbtag() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Jet::clear_trackcountinghighpurbtag() {
  trackcountinghighpurbtag_ = 0;
  clear_has_trackcountinghighpurbtag();
}
inline double Jet::trackcountinghighpurbtag() const {
  return trackcountinghighpurbtag_;
}
inline void Jet::set_trackcountinghighpurbtag(double value) {
  set_has_trackcountinghighpurbtag();
  trackcountinghighpurbtag_ = value;
}

// optional double SimpleSecondaryVertexHighEffBTag = 29 [default = 0];
inline bool Jet::has_simplesecondaryvertexhigheffbtag() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Jet::set_has_simplesecondaryvertexhigheffbtag() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Jet::clear_has_simplesecondaryvertexhigheffbtag() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Jet::clear_simplesecondaryvertexhigheffbtag() {
  simplesecondaryvertexhigheffbtag_ = 0;
  clear_has_simplesecondaryvertexhigheffbtag();
}
inline double Jet::simplesecondaryvertexhigheffbtag() const {
  return simplesecondaryvertexhigheffbtag_;
}
inline void Jet::set_simplesecondaryvertexhigheffbtag(double value) {
  set_has_simplesecondaryvertexhigheffbtag();
  simplesecondaryvertexhigheffbtag_ = value;
}

// optional double SimpleSecondaryVertexHighPurBTag = 30 [default = 0];
inline bool Jet::has_simplesecondaryvertexhighpurbtag() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Jet::set_has_simplesecondaryvertexhighpurbtag() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Jet::clear_has_simplesecondaryvertexhighpurbtag() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Jet::clear_simplesecondaryvertexhighpurbtag() {
  simplesecondaryvertexhighpurbtag_ = 0;
  clear_has_simplesecondaryvertexhighpurbtag();
}
inline double Jet::simplesecondaryvertexhighpurbtag() const {
  return simplesecondaryvertexhighpurbtag_;
}
inline void Jet::set_simplesecondaryvertexhighpurbtag(double value) {
  set_has_simplesecondaryvertexhighpurbtag();
  simplesecondaryvertexhighpurbtag_ = value;
}

// optional double JetProbabilityBTag = 31 [default = 0];
inline bool Jet::has_jetprobabilitybtag() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Jet::set_has_jetprobabilitybtag() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Jet::clear_has_jetprobabilitybtag() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Jet::clear_jetprobabilitybtag() {
  jetprobabilitybtag_ = 0;
  clear_has_jetprobabilitybtag();
}
inline double Jet::jetprobabilitybtag() const {
  return jetprobabilitybtag_;
}
inline void Jet::set_jetprobabilitybtag(double value) {
  set_has_jetprobabilitybtag();
  jetprobabilitybtag_ = value;
}

// optional double JetBProbabilityBTag = 32 [default = 0];
inline bool Jet::has_jetbprobabilitybtag() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Jet::set_has_jetbprobabilitybtag() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Jet::clear_has_jetbprobabilitybtag() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Jet::clear_jetbprobabilitybtag() {
  jetbprobabilitybtag_ = 0;
  clear_has_jetbprobabilitybtag();
}
inline double Jet::jetbprobabilitybtag() const {
  return jetbprobabilitybtag_;
}
inline void Jet::set_jetbprobabilitybtag(double value) {
  set_has_jetbprobabilitybtag();
  jetbprobabilitybtag_ = value;
}

// optional double SoftElectronBJetTag = 33 [default = 0];
inline bool Jet::has_softelectronbjettag() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Jet::set_has_softelectronbjettag() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Jet::clear_has_softelectronbjettag() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Jet::clear_softelectronbjettag() {
  softelectronbjettag_ = 0;
  clear_has_softelectronbjettag();
}
inline double Jet::softelectronbjettag() const {
  return softelectronbjettag_;
}
inline void Jet::set_softelectronbjettag(double value) {
  set_has_softelectronbjettag();
  softelectronbjettag_ = value;
}

// optional double SoftMuonBJetTag = 34 [default = 0];
inline bool Jet::has_softmuonbjettag() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Jet::set_has_softmuonbjettag() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Jet::clear_has_softmuonbjettag() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Jet::clear_softmuonbjettag() {
  softmuonbjettag_ = 0;
  clear_has_softmuonbjettag();
}
inline double Jet::softmuonbjettag() const {
  return softmuonbjettag_;
}
inline void Jet::set_softmuonbjettag(double value) {
  set_has_softmuonbjettag();
  softmuonbjettag_ = value;
}

// optional double SoftMuonNoIPBJetTag = 35 [default = 0];
inline bool Jet::has_softmuonnoipbjettag() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Jet::set_has_softmuonnoipbjettag() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Jet::clear_has_softmuonnoipbjettag() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Jet::clear_softmuonnoipbjettag() {
  softmuonnoipbjettag_ = 0;
  clear_has_softmuonnoipbjettag();
}
inline double Jet::softmuonnoipbjettag() const {
  return softmuonnoipbjettag_;
}
inline void Jet::set_softmuonnoipbjettag(double value) {
  set_has_softmuonnoipbjettag();
  softmuonnoipbjettag_ = value;
}

// optional double CombinedSVBJetTag = 36 [default = 0];
inline bool Jet::has_combinedsvbjettag() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Jet::set_has_combinedsvbjettag() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Jet::clear_has_combinedsvbjettag() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Jet::clear_combinedsvbjettag() {
  combinedsvbjettag_ = 0;
  clear_has_combinedsvbjettag();
}
inline double Jet::combinedsvbjettag() const {
  return combinedsvbjettag_;
}
inline void Jet::set_combinedsvbjettag(double value) {
  set_has_combinedsvbjettag();
  combinedsvbjettag_ = value;
}

// optional double CombinedSVMVABJetTag = 37 [default = 0];
inline bool Jet::has_combinedsvmvabjettag() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Jet::set_has_combinedsvmvabjettag() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Jet::clear_has_combinedsvmvabjettag() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Jet::clear_combinedsvmvabjettag() {
  combinedsvmvabjettag_ = 0;
  clear_has_combinedsvmvabjettag();
}
inline double Jet::combinedsvmvabjettag() const {
  return combinedsvmvabjettag_;
}
inline void Jet::set_combinedsvmvabjettag(double value) {
  set_has_combinedsvmvabjettag();
  combinedsvmvabjettag_ = value;
}

// optional int32 PassLooseID = 38 [default = 0];
inline bool Jet::has_passlooseid() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Jet::set_has_passlooseid() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Jet::clear_has_passlooseid() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Jet::clear_passlooseid() {
  passlooseid_ = 0;
  clear_has_passlooseid();
}
inline ::google::protobuf::int32 Jet::passlooseid() const {
  return passlooseid_;
}
inline void Jet::set_passlooseid(::google::protobuf::int32 value) {
  set_has_passlooseid();
  passlooseid_ = value;
}

// optional int32 PassTightID = 39 [default = 0];
inline bool Jet::has_passtightid() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Jet::set_has_passtightid() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Jet::clear_has_passtightid() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Jet::clear_passtightid() {
  passtightid_ = 0;
  clear_has_passtightid();
}
inline ::google::protobuf::int32 Jet::passtightid() const {
  return passtightid_;
}
inline void Jet::set_passtightid(::google::protobuf::int32 value) {
  set_has_passtightid();
  passtightid_ = value;
}

// optional double ChargedEmEnergyFraction = 40 [default = 0];
inline bool Jet::has_chargedemenergyfraction() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Jet::set_has_chargedemenergyfraction() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Jet::clear_has_chargedemenergyfraction() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Jet::clear_chargedemenergyfraction() {
  chargedemenergyfraction_ = 0;
  clear_has_chargedemenergyfraction();
}
inline double Jet::chargedemenergyfraction() const {
  return chargedemenergyfraction_;
}
inline void Jet::set_chargedemenergyfraction(double value) {
  set_has_chargedemenergyfraction();
  chargedemenergyfraction_ = value;
}

// optional double ChargedHadronEnergyFraction = 41 [default = 0];
inline bool Jet::has_chargedhadronenergyfraction() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Jet::set_has_chargedhadronenergyfraction() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Jet::clear_has_chargedhadronenergyfraction() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Jet::clear_chargedhadronenergyfraction() {
  chargedhadronenergyfraction_ = 0;
  clear_has_chargedhadronenergyfraction();
}
inline double Jet::chargedhadronenergyfraction() const {
  return chargedhadronenergyfraction_;
}
inline void Jet::set_chargedhadronenergyfraction(double value) {
  set_has_chargedhadronenergyfraction();
  chargedhadronenergyfraction_ = value;
}

// optional double ChargedMuEnergyFraction = 42 [default = 0];
inline bool Jet::has_chargedmuenergyfraction() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Jet::set_has_chargedmuenergyfraction() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Jet::clear_has_chargedmuenergyfraction() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Jet::clear_chargedmuenergyfraction() {
  chargedmuenergyfraction_ = 0;
  clear_has_chargedmuenergyfraction();
}
inline double Jet::chargedmuenergyfraction() const {
  return chargedmuenergyfraction_;
}
inline void Jet::set_chargedmuenergyfraction(double value) {
  set_has_chargedmuenergyfraction();
  chargedmuenergyfraction_ = value;
}

// optional double ElectronEnergyFraction = 43 [default = 0];
inline bool Jet::has_electronenergyfraction() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Jet::set_has_electronenergyfraction() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Jet::clear_has_electronenergyfraction() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void Jet::clear_electronenergyfraction() {
  electronenergyfraction_ = 0;
  clear_has_electronenergyfraction();
}
inline double Jet::electronenergyfraction() const {
  return electronenergyfraction_;
}
inline void Jet::set_electronenergyfraction(double value) {
  set_has_electronenergyfraction();
  electronenergyfraction_ = value;
}

// optional double MuonEnergyFraction = 44 [default = 0];
inline bool Jet::has_muonenergyfraction() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Jet::set_has_muonenergyfraction() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Jet::clear_has_muonenergyfraction() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Jet::clear_muonenergyfraction() {
  muonenergyfraction_ = 0;
  clear_has_muonenergyfraction();
}
inline double Jet::muonenergyfraction() const {
  return muonenergyfraction_;
}
inline void Jet::set_muonenergyfraction(double value) {
  set_has_muonenergyfraction();
  muonenergyfraction_ = value;
}

// optional double NeutralEmEnergyFraction = 45 [default = 0];
inline bool Jet::has_neutralemenergyfraction() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void Jet::set_has_neutralemenergyfraction() {
  _has_bits_[1] |= 0x00001000u;
}
inline void Jet::clear_has_neutralemenergyfraction() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void Jet::clear_neutralemenergyfraction() {
  neutralemenergyfraction_ = 0;
  clear_has_neutralemenergyfraction();
}
inline double Jet::neutralemenergyfraction() const {
  return neutralemenergyfraction_;
}
inline void Jet::set_neutralemenergyfraction(double value) {
  set_has_neutralemenergyfraction();
  neutralemenergyfraction_ = value;
}

// optional double NeutralHadronEnergyFraction = 46 [default = 0];
inline bool Jet::has_neutralhadronenergyfraction() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void Jet::set_has_neutralhadronenergyfraction() {
  _has_bits_[1] |= 0x00002000u;
}
inline void Jet::clear_has_neutralhadronenergyfraction() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void Jet::clear_neutralhadronenergyfraction() {
  neutralhadronenergyfraction_ = 0;
  clear_has_neutralhadronenergyfraction();
}
inline double Jet::neutralhadronenergyfraction() const {
  return neutralhadronenergyfraction_;
}
inline void Jet::set_neutralhadronenergyfraction(double value) {
  set_has_neutralhadronenergyfraction();
  neutralhadronenergyfraction_ = value;
}

// optional double PhotonEnergyFraction = 47 [default = 0];
inline bool Jet::has_photonenergyfraction() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void Jet::set_has_photonenergyfraction() {
  _has_bits_[1] |= 0x00004000u;
}
inline void Jet::clear_has_photonenergyfraction() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void Jet::clear_photonenergyfraction() {
  photonenergyfraction_ = 0;
  clear_has_photonenergyfraction();
}
inline double Jet::photonenergyfraction() const {
  return photonenergyfraction_;
}
inline void Jet::set_photonenergyfraction(double value) {
  set_has_photonenergyfraction();
  photonenergyfraction_ = value;
}

// optional int32 ChargedHadronMultiplicity = 48 [default = 0];
inline bool Jet::has_chargedhadronmultiplicity() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void Jet::set_has_chargedhadronmultiplicity() {
  _has_bits_[1] |= 0x00008000u;
}
inline void Jet::clear_has_chargedhadronmultiplicity() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void Jet::clear_chargedhadronmultiplicity() {
  chargedhadronmultiplicity_ = 0;
  clear_has_chargedhadronmultiplicity();
}
inline ::google::protobuf::int32 Jet::chargedhadronmultiplicity() const {
  return chargedhadronmultiplicity_;
}
inline void Jet::set_chargedhadronmultiplicity(::google::protobuf::int32 value) {
  set_has_chargedhadronmultiplicity();
  chargedhadronmultiplicity_ = value;
}

// optional int32 ChargedMultiplicity = 49 [default = 0];
inline bool Jet::has_chargedmultiplicity() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void Jet::set_has_chargedmultiplicity() {
  _has_bits_[1] |= 0x00010000u;
}
inline void Jet::clear_has_chargedmultiplicity() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void Jet::clear_chargedmultiplicity() {
  chargedmultiplicity_ = 0;
  clear_has_chargedmultiplicity();
}
inline ::google::protobuf::int32 Jet::chargedmultiplicity() const {
  return chargedmultiplicity_;
}
inline void Jet::set_chargedmultiplicity(::google::protobuf::int32 value) {
  set_has_chargedmultiplicity();
  chargedmultiplicity_ = value;
}

// optional int32 ElectronMultiplicity = 50 [default = 0];
inline bool Jet::has_electronmultiplicity() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void Jet::set_has_electronmultiplicity() {
  _has_bits_[1] |= 0x00020000u;
}
inline void Jet::clear_has_electronmultiplicity() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void Jet::clear_electronmultiplicity() {
  electronmultiplicity_ = 0;
  clear_has_electronmultiplicity();
}
inline ::google::protobuf::int32 Jet::electronmultiplicity() const {
  return electronmultiplicity_;
}
inline void Jet::set_electronmultiplicity(::google::protobuf::int32 value) {
  set_has_electronmultiplicity();
  electronmultiplicity_ = value;
}

// optional int32 MuonMultiplicity = 51 [default = 0];
inline bool Jet::has_muonmultiplicity() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void Jet::set_has_muonmultiplicity() {
  _has_bits_[1] |= 0x00040000u;
}
inline void Jet::clear_has_muonmultiplicity() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void Jet::clear_muonmultiplicity() {
  muonmultiplicity_ = 0;
  clear_has_muonmultiplicity();
}
inline ::google::protobuf::int32 Jet::muonmultiplicity() const {
  return muonmultiplicity_;
}
inline void Jet::set_muonmultiplicity(::google::protobuf::int32 value) {
  set_has_muonmultiplicity();
  muonmultiplicity_ = value;
}

// optional int32 NeutralHadronMultiplicity = 52 [default = 0];
inline bool Jet::has_neutralhadronmultiplicity() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void Jet::set_has_neutralhadronmultiplicity() {
  _has_bits_[1] |= 0x00080000u;
}
inline void Jet::clear_has_neutralhadronmultiplicity() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void Jet::clear_neutralhadronmultiplicity() {
  neutralhadronmultiplicity_ = 0;
  clear_has_neutralhadronmultiplicity();
}
inline ::google::protobuf::int32 Jet::neutralhadronmultiplicity() const {
  return neutralhadronmultiplicity_;
}
inline void Jet::set_neutralhadronmultiplicity(::google::protobuf::int32 value) {
  set_has_neutralhadronmultiplicity();
  neutralhadronmultiplicity_ = value;
}

// optional int32 NeutralMultiplicity = 53 [default = 0];
inline bool Jet::has_neutralmultiplicity() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void Jet::set_has_neutralmultiplicity() {
  _has_bits_[1] |= 0x00100000u;
}
inline void Jet::clear_has_neutralmultiplicity() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void Jet::clear_neutralmultiplicity() {
  neutralmultiplicity_ = 0;
  clear_has_neutralmultiplicity();
}
inline ::google::protobuf::int32 Jet::neutralmultiplicity() const {
  return neutralmultiplicity_;
}
inline void Jet::set_neutralmultiplicity(::google::protobuf::int32 value) {
  set_has_neutralmultiplicity();
  neutralmultiplicity_ = value;
}

// optional int32 PhotonMultiplicity = 54 [default = 0];
inline bool Jet::has_photonmultiplicity() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void Jet::set_has_photonmultiplicity() {
  _has_bits_[1] |= 0x00200000u;
}
inline void Jet::clear_has_photonmultiplicity() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void Jet::clear_photonmultiplicity() {
  photonmultiplicity_ = 0;
  clear_has_photonmultiplicity();
}
inline ::google::protobuf::int32 Jet::photonmultiplicity() const {
  return photonmultiplicity_;
}
inline void Jet::set_photonmultiplicity(::google::protobuf::int32 value) {
  set_has_photonmultiplicity();
  photonmultiplicity_ = value;
}

// optional int32 NConstituents = 55 [default = 0];
inline bool Jet::has_nconstituents() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void Jet::set_has_nconstituents() {
  _has_bits_[1] |= 0x00400000u;
}
inline void Jet::clear_has_nconstituents() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void Jet::clear_nconstituents() {
  nconstituents_ = 0;
  clear_has_nconstituents();
}
inline ::google::protobuf::int32 Jet::nconstituents() const {
  return nconstituents_;
}
inline void Jet::set_nconstituents(::google::protobuf::int32 value) {
  set_has_nconstituents();
  nconstituents_ = value;
}

// optional double ChargedEmEnergyFractionRAW = 56 [default = 0];
inline bool Jet::has_chargedemenergyfractionraw() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void Jet::set_has_chargedemenergyfractionraw() {
  _has_bits_[1] |= 0x00800000u;
}
inline void Jet::clear_has_chargedemenergyfractionraw() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void Jet::clear_chargedemenergyfractionraw() {
  chargedemenergyfractionraw_ = 0;
  clear_has_chargedemenergyfractionraw();
}
inline double Jet::chargedemenergyfractionraw() const {
  return chargedemenergyfractionraw_;
}
inline void Jet::set_chargedemenergyfractionraw(double value) {
  set_has_chargedemenergyfractionraw();
  chargedemenergyfractionraw_ = value;
}

// optional double ChargedHadronEnergyFractionRAW = 57 [default = 0];
inline bool Jet::has_chargedhadronenergyfractionraw() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void Jet::set_has_chargedhadronenergyfractionraw() {
  _has_bits_[1] |= 0x01000000u;
}
inline void Jet::clear_has_chargedhadronenergyfractionraw() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void Jet::clear_chargedhadronenergyfractionraw() {
  chargedhadronenergyfractionraw_ = 0;
  clear_has_chargedhadronenergyfractionraw();
}
inline double Jet::chargedhadronenergyfractionraw() const {
  return chargedhadronenergyfractionraw_;
}
inline void Jet::set_chargedhadronenergyfractionraw(double value) {
  set_has_chargedhadronenergyfractionraw();
  chargedhadronenergyfractionraw_ = value;
}

// optional double NeutralEmEnergyFractionRAW = 58 [default = 0];
inline bool Jet::has_neutralemenergyfractionraw() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void Jet::set_has_neutralemenergyfractionraw() {
  _has_bits_[1] |= 0x02000000u;
}
inline void Jet::clear_has_neutralemenergyfractionraw() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void Jet::clear_neutralemenergyfractionraw() {
  neutralemenergyfractionraw_ = 0;
  clear_has_neutralemenergyfractionraw();
}
inline double Jet::neutralemenergyfractionraw() const {
  return neutralemenergyfractionraw_;
}
inline void Jet::set_neutralemenergyfractionraw(double value) {
  set_has_neutralemenergyfractionraw();
  neutralemenergyfractionraw_ = value;
}

// optional double NeutralHadronEnergyFractionRAW = 59 [default = 0];
inline bool Jet::has_neutralhadronenergyfractionraw() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void Jet::set_has_neutralhadronenergyfractionraw() {
  _has_bits_[1] |= 0x04000000u;
}
inline void Jet::clear_has_neutralhadronenergyfractionraw() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void Jet::clear_neutralhadronenergyfractionraw() {
  neutralhadronenergyfractionraw_ = 0;
  clear_has_neutralhadronenergyfractionraw();
}
inline double Jet::neutralhadronenergyfractionraw() const {
  return neutralhadronenergyfractionraw_;
}
inline void Jet::set_neutralhadronenergyfractionraw(double value) {
  set_has_neutralhadronenergyfractionraw();
  neutralhadronenergyfractionraw_ = value;
}

// optional double BestVertexTrackAssociationFactor = 60 [default = 0];
inline bool Jet::has_bestvertextrackassociationfactor() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void Jet::set_has_bestvertextrackassociationfactor() {
  _has_bits_[1] |= 0x08000000u;
}
inline void Jet::clear_has_bestvertextrackassociationfactor() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void Jet::clear_bestvertextrackassociationfactor() {
  bestvertextrackassociationfactor_ = 0;
  clear_has_bestvertextrackassociationfactor();
}
inline double Jet::bestvertextrackassociationfactor() const {
  return bestvertextrackassociationfactor_;
}
inline void Jet::set_bestvertextrackassociationfactor(double value) {
  set_has_bestvertextrackassociationfactor();
  bestvertextrackassociationfactor_ = value;
}

// optional double ClosestVertexWeighted3DSeparation = 61 [default = 0];
inline bool Jet::has_closestvertexweighted3dseparation() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void Jet::set_has_closestvertexweighted3dseparation() {
  _has_bits_[1] |= 0x10000000u;
}
inline void Jet::clear_has_closestvertexweighted3dseparation() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void Jet::clear_closestvertexweighted3dseparation() {
  closestvertexweighted3dseparation_ = 0;
  clear_has_closestvertexweighted3dseparation();
}
inline double Jet::closestvertexweighted3dseparation() const {
  return closestvertexweighted3dseparation_;
}
inline void Jet::set_closestvertexweighted3dseparation(double value) {
  set_has_closestvertexweighted3dseparation();
  closestvertexweighted3dseparation_ = value;
}

// optional double ClosestVertexWeightedXYSeparation = 62 [default = 0];
inline bool Jet::has_closestvertexweightedxyseparation() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void Jet::set_has_closestvertexweightedxyseparation() {
  _has_bits_[1] |= 0x20000000u;
}
inline void Jet::clear_has_closestvertexweightedxyseparation() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void Jet::clear_closestvertexweightedxyseparation() {
  closestvertexweightedxyseparation_ = 0;
  clear_has_closestvertexweightedxyseparation();
}
inline double Jet::closestvertexweightedxyseparation() const {
  return closestvertexweightedxyseparation_;
}
inline void Jet::set_closestvertexweightedxyseparation(double value) {
  set_has_closestvertexweightedxyseparation();
  closestvertexweightedxyseparation_ = value;
}

// optional double ClosestVertexWeightedZSeparation = 63 [default = 0];
inline bool Jet::has_closestvertexweightedzseparation() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void Jet::set_has_closestvertexweightedzseparation() {
  _has_bits_[1] |= 0x40000000u;
}
inline void Jet::clear_has_closestvertexweightedzseparation() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void Jet::clear_closestvertexweightedzseparation() {
  closestvertexweightedzseparation_ = 0;
  clear_has_closestvertexweightedzseparation();
}
inline double Jet::closestvertexweightedzseparation() const {
  return closestvertexweightedzseparation_;
}
inline void Jet::set_closestvertexweightedzseparation(double value) {
  set_has_closestvertexweightedzseparation();
  closestvertexweightedzseparation_ = value;
}

// optional int32 BestVertexTrackAssociationIndex = 64 [default = 0];
inline bool Jet::has_bestvertextrackassociationindex() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void Jet::set_has_bestvertextrackassociationindex() {
  _has_bits_[1] |= 0x80000000u;
}
inline void Jet::clear_has_bestvertextrackassociationindex() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void Jet::clear_bestvertextrackassociationindex() {
  bestvertextrackassociationindex_ = 0;
  clear_has_bestvertextrackassociationindex();
}
inline ::google::protobuf::int32 Jet::bestvertextrackassociationindex() const {
  return bestvertextrackassociationindex_;
}
inline void Jet::set_bestvertextrackassociationindex(::google::protobuf::int32 value) {
  set_has_bestvertextrackassociationindex();
  bestvertextrackassociationindex_ = value;
}

// optional int32 ClosestVertex3DIndex = 65 [default = 0];
inline bool Jet::has_closestvertex3dindex() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void Jet::set_has_closestvertex3dindex() {
  _has_bits_[2] |= 0x00000001u;
}
inline void Jet::clear_has_closestvertex3dindex() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void Jet::clear_closestvertex3dindex() {
  closestvertex3dindex_ = 0;
  clear_has_closestvertex3dindex();
}
inline ::google::protobuf::int32 Jet::closestvertex3dindex() const {
  return closestvertex3dindex_;
}
inline void Jet::set_closestvertex3dindex(::google::protobuf::int32 value) {
  set_has_closestvertex3dindex();
  closestvertex3dindex_ = value;
}

// optional int32 ClosestVertexXYIndex = 66 [default = 0];
inline bool Jet::has_closestvertexxyindex() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void Jet::set_has_closestvertexxyindex() {
  _has_bits_[2] |= 0x00000002u;
}
inline void Jet::clear_has_closestvertexxyindex() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void Jet::clear_closestvertexxyindex() {
  closestvertexxyindex_ = 0;
  clear_has_closestvertexxyindex();
}
inline ::google::protobuf::int32 Jet::closestvertexxyindex() const {
  return closestvertexxyindex_;
}
inline void Jet::set_closestvertexxyindex(::google::protobuf::int32 value) {
  set_has_closestvertexxyindex();
  closestvertexxyindex_ = value;
}

// optional int32 ClosestVertexZIndex = 67 [default = 0];
inline bool Jet::has_closestvertexzindex() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void Jet::set_has_closestvertexzindex() {
  _has_bits_[2] |= 0x00000004u;
}
inline void Jet::clear_has_closestvertexzindex() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void Jet::clear_closestvertexzindex() {
  closestvertexzindex_ = 0;
  clear_has_closestvertexzindex();
}
inline ::google::protobuf::int32 Jet::closestvertexzindex() const {
  return closestvertexzindex_;
}
inline void Jet::set_closestvertexzindex(::google::protobuf::int32 value) {
  set_has_closestvertexzindex();
  closestvertexzindex_ = value;
}

// -------------------------------------------------------------------

// GenJet

// optional double Energy = 1 [default = 0];
inline bool GenJet::has_energy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenJet::set_has_energy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenJet::clear_has_energy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenJet::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline double GenJet::energy() const {
  return energy_;
}
inline void GenJet::set_energy(double value) {
  set_has_energy();
  energy_ = value;
}

// optional double Px = 2 [default = 0];
inline bool GenJet::has_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenJet::set_has_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenJet::clear_has_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenJet::clear_px() {
  px_ = 0;
  clear_has_px();
}
inline double GenJet::px() const {
  return px_;
}
inline void GenJet::set_px(double value) {
  set_has_px();
  px_ = value;
}

// optional double Py = 3 [default = 0];
inline bool GenJet::has_py() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GenJet::set_has_py() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GenJet::clear_has_py() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GenJet::clear_py() {
  py_ = 0;
  clear_has_py();
}
inline double GenJet::py() const {
  return py_;
}
inline void GenJet::set_py(double value) {
  set_has_py();
  py_ = value;
}

// optional double Pz = 4 [default = 0];
inline bool GenJet::has_pz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GenJet::set_has_pz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GenJet::clear_has_pz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GenJet::clear_pz() {
  pz_ = 0;
  clear_has_pz();
}
inline double GenJet::pz() const {
  return pz_;
}
inline void GenJet::set_pz(double value) {
  set_has_pz();
  pz_ = value;
}

// optional double Charge = 5 [default = 0];
inline bool GenJet::has_charge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GenJet::set_has_charge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GenJet::clear_has_charge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GenJet::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline double GenJet::charge() const {
  return charge_;
}
inline void GenJet::set_charge(double value) {
  set_has_charge();
  charge_ = value;
}

// optional double Mass = 6 [default = 0];
inline bool GenJet::has_mass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GenJet::set_has_mass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GenJet::clear_has_mass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GenJet::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double GenJet::mass() const {
  return mass_;
}
inline void GenJet::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// optional double Eta = 7 [default = 0];
inline bool GenJet::has_eta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GenJet::set_has_eta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GenJet::clear_has_eta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GenJet::clear_eta() {
  eta_ = 0;
  clear_has_eta();
}
inline double GenJet::eta() const {
  return eta_;
}
inline void GenJet::set_eta(double value) {
  set_has_eta();
  eta_ = value;
}

// optional double Phi = 8 [default = 0];
inline bool GenJet::has_phi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GenJet::set_has_phi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GenJet::clear_has_phi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GenJet::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double GenJet::phi() const {
  return phi_;
}
inline void GenJet::set_phi(double value) {
  set_has_phi();
  phi_ = value;
}

// optional double Pt = 9 [default = 0];
inline bool GenJet::has_pt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GenJet::set_has_pt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GenJet::clear_has_pt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GenJet::clear_pt() {
  pt_ = 0;
  clear_has_pt();
}
inline double GenJet::pt() const {
  return pt_;
}
inline void GenJet::set_pt(double value) {
  set_has_pt();
  pt_ = value;
}

// optional double EMF = 10 [default = 0];
inline bool GenJet::has_emf() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GenJet::set_has_emf() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GenJet::clear_has_emf() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GenJet::clear_emf() {
  emf_ = 0;
  clear_has_emf();
}
inline double GenJet::emf() const {
  return emf_;
}
inline void GenJet::set_emf(double value) {
  set_has_emf();
  emf_ = value;
}

// optional double HADF = 11 [default = 0];
inline bool GenJet::has_hadf() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GenJet::set_has_hadf() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GenJet::clear_has_hadf() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GenJet::clear_hadf() {
  hadf_ = 0;
  clear_has_hadf();
}
inline double GenJet::hadf() const {
  return hadf_;
}
inline void GenJet::set_hadf(double value) {
  set_has_hadf();
  hadf_ = value;
}

// -------------------------------------------------------------------

// GenParticle

// optional double Energy = 1 [default = 0];
inline bool GenParticle::has_energy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenParticle::set_has_energy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenParticle::clear_has_energy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenParticle::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline double GenParticle::energy() const {
  return energy_;
}
inline void GenParticle::set_energy(double value) {
  set_has_energy();
  energy_ = value;
}

// optional double Px = 2 [default = 0];
inline bool GenParticle::has_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenParticle::set_has_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenParticle::clear_has_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenParticle::clear_px() {
  px_ = 0;
  clear_has_px();
}
inline double GenParticle::px() const {
  return px_;
}
inline void GenParticle::set_px(double value) {
  set_has_px();
  px_ = value;
}

// optional double Py = 3 [default = 0];
inline bool GenParticle::has_py() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GenParticle::set_has_py() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GenParticle::clear_has_py() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GenParticle::clear_py() {
  py_ = 0;
  clear_has_py();
}
inline double GenParticle::py() const {
  return py_;
}
inline void GenParticle::set_py(double value) {
  set_has_py();
  py_ = value;
}

// optional double Pz = 4 [default = 0];
inline bool GenParticle::has_pz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GenParticle::set_has_pz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GenParticle::clear_has_pz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GenParticle::clear_pz() {
  pz_ = 0;
  clear_has_pz();
}
inline double GenParticle::pz() const {
  return pz_;
}
inline void GenParticle::set_pz(double value) {
  set_has_pz();
  pz_ = value;
}

// optional double Charge = 5 [default = 0];
inline bool GenParticle::has_charge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GenParticle::set_has_charge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GenParticle::clear_has_charge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GenParticle::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline double GenParticle::charge() const {
  return charge_;
}
inline void GenParticle::set_charge(double value) {
  set_has_charge();
  charge_ = value;
}

// optional double Mass = 6 [default = 0];
inline bool GenParticle::has_mass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GenParticle::set_has_mass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GenParticle::clear_has_mass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GenParticle::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double GenParticle::mass() const {
  return mass_;
}
inline void GenParticle::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// optional double Eta = 7 [default = 0];
inline bool GenParticle::has_eta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GenParticle::set_has_eta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GenParticle::clear_has_eta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GenParticle::clear_eta() {
  eta_ = 0;
  clear_has_eta();
}
inline double GenParticle::eta() const {
  return eta_;
}
inline void GenParticle::set_eta(double value) {
  set_has_eta();
  eta_ = value;
}

// optional double Phi = 8 [default = 0];
inline bool GenParticle::has_phi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GenParticle::set_has_phi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GenParticle::clear_has_phi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GenParticle::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double GenParticle::phi() const {
  return phi_;
}
inline void GenParticle::set_phi(double value) {
  set_has_phi();
  phi_ = value;
}

// optional double Pt = 9 [default = 0];
inline bool GenParticle::has_pt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GenParticle::set_has_pt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GenParticle::clear_has_pt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GenParticle::clear_pt() {
  pt_ = 0;
  clear_has_pt();
}
inline double GenParticle::pt() const {
  return pt_;
}
inline void GenParticle::set_pt(double value) {
  set_has_pt();
  pt_ = value;
}

// optional int32 PdgId = 10 [default = 0];
inline bool GenParticle::has_pdgid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GenParticle::set_has_pdgid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GenParticle::clear_has_pdgid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GenParticle::clear_pdgid() {
  pdgid_ = 0;
  clear_has_pdgid();
}
inline ::google::protobuf::int32 GenParticle::pdgid() const {
  return pdgid_;
}
inline void GenParticle::set_pdgid(::google::protobuf::int32 value) {
  set_has_pdgid();
  pdgid_ = value;
}

// optional double VX = 11 [default = 0];
inline bool GenParticle::has_vx() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GenParticle::set_has_vx() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GenParticle::clear_has_vx() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GenParticle::clear_vx() {
  vx_ = 0;
  clear_has_vx();
}
inline double GenParticle::vx() const {
  return vx_;
}
inline void GenParticle::set_vx(double value) {
  set_has_vx();
  vx_ = value;
}

// optional double VY = 12 [default = 0];
inline bool GenParticle::has_vy() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GenParticle::set_has_vy() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GenParticle::clear_has_vy() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GenParticle::clear_vy() {
  vy_ = 0;
  clear_has_vy();
}
inline double GenParticle::vy() const {
  return vy_;
}
inline void GenParticle::set_vy(double value) {
  set_has_vy();
  vy_ = value;
}

// optional double VZ = 13 [default = 0];
inline bool GenParticle::has_vz() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GenParticle::set_has_vz() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GenParticle::clear_has_vz() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GenParticle::clear_vz() {
  vz_ = 0;
  clear_has_vz();
}
inline double GenParticle::vz() const {
  return vz_;
}
inline void GenParticle::set_vz(double value) {
  set_has_vz();
  vz_ = value;
}

// optional int32 NumDaught = 14 [default = 0];
inline bool GenParticle::has_numdaught() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GenParticle::set_has_numdaught() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GenParticle::clear_has_numdaught() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GenParticle::clear_numdaught() {
  numdaught_ = 0;
  clear_has_numdaught();
}
inline ::google::protobuf::int32 GenParticle::numdaught() const {
  return numdaught_;
}
inline void GenParticle::set_numdaught(::google::protobuf::int32 value) {
  set_has_numdaught();
  numdaught_ = value;
}

// optional int32 Status = 15 [default = 0];
inline bool GenParticle::has_status() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GenParticle::set_has_status() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GenParticle::clear_has_status() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GenParticle::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 GenParticle::status() const {
  return status_;
}
inline void GenParticle::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 MotherIndex = 16 [default = 0];
inline bool GenParticle::has_motherindex() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GenParticle::set_has_motherindex() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GenParticle::clear_has_motherindex() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GenParticle::clear_motherindex() {
  motherindex_ = 0;
  clear_has_motherindex();
}
inline ::google::protobuf::int32 GenParticle::motherindex() const {
  return motherindex_;
}
inline void GenParticle::set_motherindex(::google::protobuf::int32 value) {
  set_has_motherindex();
  motherindex_ = value;
}

// -------------------------------------------------------------------

// Electron_GSFTrack

// optional double d0 = 1 [default = 0];
inline bool Electron_GSFTrack::has_d0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Electron_GSFTrack::set_has_d0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Electron_GSFTrack::clear_has_d0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Electron_GSFTrack::clear_d0() {
  d0_ = 0;
  clear_has_d0();
}
inline double Electron_GSFTrack::d0() const {
  return d0_;
}
inline void Electron_GSFTrack::set_d0(double value) {
  set_has_d0();
  d0_ = value;
}

// optional double Eta = 2 [default = 0];
inline bool Electron_GSFTrack::has_eta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Electron_GSFTrack::set_has_eta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Electron_GSFTrack::clear_has_eta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Electron_GSFTrack::clear_eta() {
  eta_ = 0;
  clear_has_eta();
}
inline double Electron_GSFTrack::eta() const {
  return eta_;
}
inline void Electron_GSFTrack::set_eta(double value) {
  set_has_eta();
  eta_ = value;
}

// optional double Phi = 3 [default = 0];
inline bool Electron_GSFTrack::has_phi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Electron_GSFTrack::set_has_phi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Electron_GSFTrack::clear_has_phi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Electron_GSFTrack::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double Electron_GSFTrack::phi() const {
  return phi_;
}
inline void Electron_GSFTrack::set_phi(double value) {
  set_has_phi();
  phi_ = value;
}

// optional double Theta = 4 [default = 0];
inline bool Electron_GSFTrack::has_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Electron_GSFTrack::set_has_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Electron_GSFTrack::clear_has_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Electron_GSFTrack::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double Electron_GSFTrack::theta() const {
  return theta_;
}
inline void Electron_GSFTrack::set_theta(double value) {
  set_has_theta();
  theta_ = value;
}

// optional int32 Charge = 5 [default = 0];
inline bool Electron_GSFTrack::has_charge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Electron_GSFTrack::set_has_charge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Electron_GSFTrack::clear_has_charge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Electron_GSFTrack::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline ::google::protobuf::int32 Electron_GSFTrack::charge() const {
  return charge_;
}
inline void Electron_GSFTrack::set_charge(::google::protobuf::int32 value) {
  set_has_charge();
  charge_ = value;
}

// optional double Pt = 6 [default = 0];
inline bool Electron_GSFTrack::has_pt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Electron_GSFTrack::set_has_pt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Electron_GSFTrack::clear_has_pt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Electron_GSFTrack::clear_pt() {
  pt_ = 0;
  clear_has_pt();
}
inline double Electron_GSFTrack::pt() const {
  return pt_;
}
inline void Electron_GSFTrack::set_pt(double value) {
  set_has_pt();
  pt_ = value;
}

// -------------------------------------------------------------------

// Electron

// optional double Energy = 1 [default = 0];
inline bool Electron::has_energy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Electron::set_has_energy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Electron::clear_has_energy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Electron::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline double Electron::energy() const {
  return energy_;
}
inline void Electron::set_energy(double value) {
  set_has_energy();
  energy_ = value;
}

// optional double Px = 2 [default = 0];
inline bool Electron::has_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Electron::set_has_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Electron::clear_has_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Electron::clear_px() {
  px_ = 0;
  clear_has_px();
}
inline double Electron::px() const {
  return px_;
}
inline void Electron::set_px(double value) {
  set_has_px();
  px_ = value;
}

// optional double Py = 3 [default = 0];
inline bool Electron::has_py() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Electron::set_has_py() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Electron::clear_has_py() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Electron::clear_py() {
  py_ = 0;
  clear_has_py();
}
inline double Electron::py() const {
  return py_;
}
inline void Electron::set_py(double value) {
  set_has_py();
  py_ = value;
}

// optional double Pz = 4 [default = 0];
inline bool Electron::has_pz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Electron::set_has_pz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Electron::clear_has_pz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Electron::clear_pz() {
  pz_ = 0;
  clear_has_pz();
}
inline double Electron::pz() const {
  return pz_;
}
inline void Electron::set_pz(double value) {
  set_has_pz();
  pz_ = value;
}

// optional double Charge = 5 [default = 0];
inline bool Electron::has_charge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Electron::set_has_charge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Electron::clear_has_charge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Electron::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline double Electron::charge() const {
  return charge_;
}
inline void Electron::set_charge(double value) {
  set_has_charge();
  charge_ = value;
}

// optional int32 Mass = 6 [default = 0];
inline bool Electron::has_mass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Electron::set_has_mass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Electron::clear_has_mass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Electron::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline ::google::protobuf::int32 Electron::mass() const {
  return mass_;
}
inline void Electron::set_mass(::google::protobuf::int32 value) {
  set_has_mass();
  mass_ = value;
}

// optional .HEP.Electron.ElectronAlgorithm type = 7 [default = ParticleFlow];
inline bool Electron::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Electron::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Electron::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Electron::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::HEP::Electron_ElectronAlgorithm Electron::type() const {
  return static_cast< ::HEP::Electron_ElectronAlgorithm >(type_);
}
inline void Electron::set_type(::HEP::Electron_ElectronAlgorithm value) {
  GOOGLE_DCHECK(::HEP::Electron_ElectronAlgorithm_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double Eta = 8 [default = 0];
inline bool Electron::has_eta() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Electron::set_has_eta() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Electron::clear_has_eta() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Electron::clear_eta() {
  eta_ = 0;
  clear_has_eta();
}
inline double Electron::eta() const {
  return eta_;
}
inline void Electron::set_eta(double value) {
  set_has_eta();
  eta_ = value;
}

// optional double Phi = 9 [default = 0];
inline bool Electron::has_phi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Electron::set_has_phi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Electron::clear_has_phi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Electron::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double Electron::phi() const {
  return phi_;
}
inline void Electron::set_phi(double value) {
  set_has_phi();
  phi_ = value;
}

// optional double Pt = 10 [default = 0];
inline bool Electron::has_pt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Electron::set_has_pt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Electron::clear_has_pt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Electron::clear_pt() {
  pt_ = 0;
  clear_has_pt();
}
inline double Electron::pt() const {
  return pt_;
}
inline void Electron::set_pt(double value) {
  set_has_pt();
  pt_ = value;
}

// optional double CaloEnergy = 12 [default = 0];
inline bool Electron::has_caloenergy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Electron::set_has_caloenergy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Electron::clear_has_caloenergy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Electron::clear_caloenergy() {
  caloenergy_ = 0;
  clear_has_caloenergy();
}
inline double Electron::caloenergy() const {
  return caloenergy_;
}
inline void Electron::set_caloenergy(double value) {
  set_has_caloenergy();
  caloenergy_ = value;
}

// optional double HoE = 13 [default = 0];
inline bool Electron::has_hoe() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Electron::set_has_hoe() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Electron::clear_has_hoe() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Electron::clear_hoe() {
  hoe_ = 0;
  clear_has_hoe();
}
inline double Electron::hoe() const {
  return hoe_;
}
inline void Electron::set_hoe(double value) {
  set_has_hoe();
  hoe_ = value;
}

// optional double eSeedClusterOverPout = 14 [default = 0];
inline bool Electron::has_eseedclusteroverpout() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Electron::set_has_eseedclusteroverpout() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Electron::clear_has_eseedclusteroverpout() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Electron::clear_eseedclusteroverpout() {
  eseedclusteroverpout_ = 0;
  clear_has_eseedclusteroverpout();
}
inline double Electron::eseedclusteroverpout() const {
  return eseedclusteroverpout_;
}
inline void Electron::set_eseedclusteroverpout(double value) {
  set_has_eseedclusteroverpout();
  eseedclusteroverpout_ = value;
}

// optional double EoverP = 15 [default = 0];
inline bool Electron::has_eoverp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Electron::set_has_eoverp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Electron::clear_has_eoverp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Electron::clear_eoverp() {
  eoverp_ = 0;
  clear_has_eoverp();
}
inline double Electron::eoverp() const {
  return eoverp_;
}
inline void Electron::set_eoverp(double value) {
  set_has_eoverp();
  eoverp_ = value;
}

// optional double fbrem = 16 [default = 0];
inline bool Electron::has_fbrem() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Electron::set_has_fbrem() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Electron::clear_has_fbrem() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Electron::clear_fbrem() {
  fbrem_ = 0;
  clear_has_fbrem();
}
inline double Electron::fbrem() const {
  return fbrem_;
}
inline void Electron::set_fbrem(double value) {
  set_has_fbrem();
  fbrem_ = value;
}

// optional double SigmaEtaEta = 17 [default = 0];
inline bool Electron::has_sigmaetaeta() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Electron::set_has_sigmaetaeta() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Electron::clear_has_sigmaetaeta() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Electron::clear_sigmaetaeta() {
  sigmaetaeta_ = 0;
  clear_has_sigmaetaeta();
}
inline double Electron::sigmaetaeta() const {
  return sigmaetaeta_;
}
inline void Electron::set_sigmaetaeta(double value) {
  set_has_sigmaetaeta();
  sigmaetaeta_ = value;
}

// optional double SigmaIEtaIEta = 18 [default = 0];
inline bool Electron::has_sigmaietaieta() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Electron::set_has_sigmaietaieta() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Electron::clear_has_sigmaietaieta() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Electron::clear_sigmaietaieta() {
  sigmaietaieta_ = 0;
  clear_has_sigmaietaieta();
}
inline double Electron::sigmaietaieta() const {
  return sigmaietaieta_;
}
inline void Electron::set_sigmaietaieta(double value) {
  set_has_sigmaietaieta();
  sigmaietaieta_ = value;
}

// optional double DeltaPhiTrkSC = 19 [default = 0];
inline bool Electron::has_deltaphitrksc() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Electron::set_has_deltaphitrksc() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Electron::clear_has_deltaphitrksc() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Electron::clear_deltaphitrksc() {
  deltaphitrksc_ = 0;
  clear_has_deltaphitrksc();
}
inline double Electron::deltaphitrksc() const {
  return deltaphitrksc_;
}
inline void Electron::set_deltaphitrksc(double value) {
  set_has_deltaphitrksc();
  deltaphitrksc_ = value;
}

// optional double DeltaEtaTrkSC = 20 [default = 0];
inline bool Electron::has_deltaetatrksc() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Electron::set_has_deltaetatrksc() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Electron::clear_has_deltaetatrksc() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Electron::clear_deltaetatrksc() {
  deltaetatrksc_ = 0;
  clear_has_deltaetatrksc();
}
inline double Electron::deltaetatrksc() const {
  return deltaetatrksc_;
}
inline void Electron::set_deltaetatrksc(double value) {
  set_has_deltaetatrksc();
  deltaetatrksc_ = value;
}

// optional double TrkIso03 = 21 [default = 0];
inline bool Electron::has_trkiso03() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Electron::set_has_trkiso03() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Electron::clear_has_trkiso03() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Electron::clear_trkiso03() {
  trkiso03_ = 0;
  clear_has_trkiso03();
}
inline double Electron::trkiso03() const {
  return trkiso03_;
}
inline void Electron::set_trkiso03(double value) {
  set_has_trkiso03();
  trkiso03_ = value;
}

// optional double EcalIso03 = 22 [default = 0];
inline bool Electron::has_ecaliso03() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Electron::set_has_ecaliso03() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Electron::clear_has_ecaliso03() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Electron::clear_ecaliso03() {
  ecaliso03_ = 0;
  clear_has_ecaliso03();
}
inline double Electron::ecaliso03() const {
  return ecaliso03_;
}
inline void Electron::set_ecaliso03(double value) {
  set_has_ecaliso03();
  ecaliso03_ = value;
}

// optional double HcalIso03 = 23 [default = 0];
inline bool Electron::has_hcaliso03() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Electron::set_has_hcaliso03() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Electron::clear_has_hcaliso03() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Electron::clear_hcaliso03() {
  hcaliso03_ = 0;
  clear_has_hcaliso03();
}
inline double Electron::hcaliso03() const {
  return hcaliso03_;
}
inline void Electron::set_hcaliso03(double value) {
  set_has_hcaliso03();
  hcaliso03_ = value;
}

// optional double TrkIso = 24 [default = 0];
inline bool Electron::has_trkiso() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Electron::set_has_trkiso() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Electron::clear_has_trkiso() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Electron::clear_trkiso() {
  trkiso_ = 0;
  clear_has_trkiso();
}
inline double Electron::trkiso() const {
  return trkiso_;
}
inline void Electron::set_trkiso(double value) {
  set_has_trkiso();
  trkiso_ = value;
}

// optional double EcalIso = 25 [default = 0];
inline bool Electron::has_ecaliso() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Electron::set_has_ecaliso() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Electron::clear_has_ecaliso() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Electron::clear_ecaliso() {
  ecaliso_ = 0;
  clear_has_ecaliso();
}
inline double Electron::ecaliso() const {
  return ecaliso_;
}
inline void Electron::set_ecaliso(double value) {
  set_has_ecaliso();
  ecaliso_ = value;
}

// optional double HcalIso = 26 [default = 0];
inline bool Electron::has_hcaliso() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Electron::set_has_hcaliso() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Electron::clear_has_hcaliso() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Electron::clear_hcaliso() {
  hcaliso_ = 0;
  clear_has_hcaliso();
}
inline double Electron::hcaliso() const {
  return hcaliso_;
}
inline void Electron::set_hcaliso(double value) {
  set_has_hcaliso();
  hcaliso_ = value;
}

// optional double dB = 27 [default = 0];
inline bool Electron::has_db() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Electron::set_has_db() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Electron::clear_has_db() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Electron::clear_db() {
  db_ = 0;
  clear_has_db();
}
inline double Electron::db() const {
  return db_;
}
inline void Electron::set_db(double value) {
  set_has_db();
  db_ = value;
}

// optional int32 closestCtfTrackRef = 28 [default = 0];
inline bool Electron::has_closestctftrackref() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Electron::set_has_closestctftrackref() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Electron::clear_has_closestctftrackref() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Electron::clear_closestctftrackref() {
  closestctftrackref_ = 0;
  clear_has_closestctftrackref();
}
inline ::google::protobuf::int32 Electron::closestctftrackref() const {
  return closestctftrackref_;
}
inline void Electron::set_closestctftrackref(::google::protobuf::int32 value) {
  set_has_closestctftrackref();
  closestctftrackref_ = value;
}

// optional double shFracInnerHits = 29 [default = 0];
inline bool Electron::has_shfracinnerhits() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Electron::set_has_shfracinnerhits() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Electron::clear_has_shfracinnerhits() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Electron::clear_shfracinnerhits() {
  shfracinnerhits_ = 0;
  clear_has_shfracinnerhits();
}
inline double Electron::shfracinnerhits() const {
  return shfracinnerhits_;
}
inline void Electron::set_shfracinnerhits(double value) {
  set_has_shfracinnerhits();
  shfracinnerhits_ = value;
}

// repeated .HEP.Electron.GSFTrack track = 30;
inline int Electron::track_size() const {
  return track_.size();
}
inline void Electron::clear_track() {
  track_.Clear();
}
inline const ::HEP::Electron_GSFTrack& Electron::track(int index) const {
  return track_.Get(index);
}
inline ::HEP::Electron_GSFTrack* Electron::mutable_track(int index) {
  return track_.Mutable(index);
}
inline ::HEP::Electron_GSFTrack* Electron::add_track() {
  return track_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Electron_GSFTrack >&
Electron::track() const {
  return track_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Electron_GSFTrack >*
Electron::mutable_track() {
  return &track_;
}

// optional double EcalIsoHeep = 31 [default = 0];
inline bool Electron::has_ecalisoheep() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Electron::set_has_ecalisoheep() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Electron::clear_has_ecalisoheep() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Electron::clear_ecalisoheep() {
  ecalisoheep_ = 0;
  clear_has_ecalisoheep();
}
inline double Electron::ecalisoheep() const {
  return ecalisoheep_;
}
inline void Electron::set_ecalisoheep(double value) {
  set_has_ecalisoheep();
  ecalisoheep_ = value;
}

// optional double HcalIsoD1Heep = 32 [default = 0];
inline bool Electron::has_hcalisod1heep() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Electron::set_has_hcalisod1heep() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Electron::clear_has_hcalisod1heep() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Electron::clear_hcalisod1heep() {
  hcalisod1heep_ = 0;
  clear_has_hcalisod1heep();
}
inline double Electron::hcalisod1heep() const {
  return hcalisod1heep_;
}
inline void Electron::set_hcalisod1heep(double value) {
  set_has_hcalisod1heep();
  hcalisod1heep_ = value;
}

// optional double HcalIsoD2Heep = 33 [default = 0];
inline bool Electron::has_hcalisod2heep() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Electron::set_has_hcalisod2heep() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Electron::clear_has_hcalisod2heep() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Electron::clear_hcalisod2heep() {
  hcalisod2heep_ = 0;
  clear_has_hcalisod2heep();
}
inline double Electron::hcalisod2heep() const {
  return hcalisod2heep_;
}
inline void Electron::set_hcalisod2heep(double value) {
  set_has_hcalisod2heep();
  hcalisod2heep_ = value;
}

// optional double TrkIsoHeep = 34 [default = 0];
inline bool Electron::has_trkisoheep() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Electron::set_has_trkisoheep() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Electron::clear_has_trkisoheep() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Electron::clear_trkisoheep() {
  trkisoheep_ = 0;
  clear_has_trkisoheep();
}
inline double Electron::trkisoheep() const {
  return trkisoheep_;
}
inline void Electron::set_trkisoheep(double value) {
  set_has_trkisoheep();
  trkisoheep_ = value;
}

// optional int32 MissingHits = 35 [default = 0];
inline bool Electron::has_missinghits() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Electron::set_has_missinghits() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Electron::clear_has_missinghits() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Electron::clear_missinghits() {
  missinghits_ = 0;
  clear_has_missinghits();
}
inline ::google::protobuf::int32 Electron::missinghits() const {
  return missinghits_;
}
inline void Electron::set_missinghits(::google::protobuf::int32 value) {
  set_has_missinghits();
  missinghits_ = value;
}

// optional double Dist = 36 [default = 0];
inline bool Electron::has_dist() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Electron::set_has_dist() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Electron::clear_has_dist() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Electron::clear_dist() {
  dist_ = 0;
  clear_has_dist();
}
inline double Electron::dist() const {
  return dist_;
}
inline void Electron::set_dist(double value) {
  set_has_dist();
  dist_ = value;
}

// optional double DCotTheta = 37 [default = 0];
inline bool Electron::has_dcottheta() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Electron::set_has_dcottheta() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Electron::clear_has_dcottheta() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Electron::clear_dcottheta() {
  dcottheta_ = 0;
  clear_has_dcottheta();
}
inline double Electron::dcottheta() const {
  return dcottheta_;
}
inline void Electron::set_dcottheta(double value) {
  set_has_dcottheta();
  dcottheta_ = value;
}

// optional double SCEta = 38 [default = 0];
inline bool Electron::has_sceta() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Electron::set_has_sceta() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Electron::clear_has_sceta() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Electron::clear_sceta() {
  sceta_ = 0;
  clear_has_sceta();
}
inline double Electron::sceta() const {
  return sceta_;
}
inline void Electron::set_sceta(double value) {
  set_has_sceta();
  sceta_ = value;
}

// optional double SCPhi = 39 [default = 0];
inline bool Electron::has_scphi() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Electron::set_has_scphi() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Electron::clear_has_scphi() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Electron::clear_scphi() {
  scphi_ = 0;
  clear_has_scphi();
}
inline double Electron::scphi() const {
  return scphi_;
}
inline void Electron::set_scphi(double value) {
  set_has_scphi();
  scphi_ = value;
}

// optional double SCPt = 40 [default = 0];
inline bool Electron::has_scpt() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Electron::set_has_scpt() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Electron::clear_has_scpt() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Electron::clear_scpt() {
  scpt_ = 0;
  clear_has_scpt();
}
inline double Electron::scpt() const {
  return scpt_;
}
inline void Electron::set_scpt(double value) {
  set_has_scpt();
  scpt_ = value;
}

// optional double SCRawEnergy = 41 [default = 0];
inline bool Electron::has_scrawenergy() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Electron::set_has_scrawenergy() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Electron::clear_has_scrawenergy() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Electron::clear_scrawenergy() {
  scrawenergy_ = 0;
  clear_has_scrawenergy();
}
inline double Electron::scrawenergy() const {
  return scrawenergy_;
}
inline void Electron::set_scrawenergy(double value) {
  set_has_scrawenergy();
  scrawenergy_ = value;
}

// optional int32 VtxIndex = 42 [default = 0];
inline bool Electron::has_vtxindex() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Electron::set_has_vtxindex() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Electron::clear_has_vtxindex() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Electron::clear_vtxindex() {
  vtxindex_ = 0;
  clear_has_vtxindex();
}
inline ::google::protobuf::int32 Electron::vtxindex() const {
  return vtxindex_;
}
inline void Electron::set_vtxindex(::google::protobuf::int32 value) {
  set_has_vtxindex();
  vtxindex_ = value;
}

// optional double VtxDistXY = 43 [default = 0];
inline bool Electron::has_vtxdistxy() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Electron::set_has_vtxdistxy() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Electron::clear_has_vtxdistxy() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Electron::clear_vtxdistxy() {
  vtxdistxy_ = 0;
  clear_has_vtxdistxy();
}
inline double Electron::vtxdistxy() const {
  return vtxdistxy_;
}
inline void Electron::set_vtxdistxy(double value) {
  set_has_vtxdistxy();
  vtxdistxy_ = value;
}

// optional double VtxDistZ = 44 [default = 0];
inline bool Electron::has_vtxdistz() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Electron::set_has_vtxdistz() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Electron::clear_has_vtxdistz() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void Electron::clear_vtxdistz() {
  vtxdistz_ = 0;
  clear_has_vtxdistz();
}
inline double Electron::vtxdistz() const {
  return vtxdistz_;
}
inline void Electron::set_vtxdistz(double value) {
  set_has_vtxdistz();
  vtxdistz_ = value;
}

// optional double VertexX = 45 [default = 0];
inline bool Electron::has_vertexx() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Electron::set_has_vertexx() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Electron::clear_has_vertexx() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Electron::clear_vertexx() {
  vertexx_ = 0;
  clear_has_vertexx();
}
inline double Electron::vertexx() const {
  return vertexx_;
}
inline void Electron::set_vertexx(double value) {
  set_has_vertexx();
  vertexx_ = value;
}

// optional double VertexY = 46 [default = 0];
inline bool Electron::has_vertexy() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void Electron::set_has_vertexy() {
  _has_bits_[1] |= 0x00001000u;
}
inline void Electron::clear_has_vertexy() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void Electron::clear_vertexy() {
  vertexy_ = 0;
  clear_has_vertexy();
}
inline double Electron::vertexy() const {
  return vertexy_;
}
inline void Electron::set_vertexy(double value) {
  set_has_vertexy();
  vertexy_ = value;
}

// optional double VertexZ = 47 [default = 0];
inline bool Electron::has_vertexz() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void Electron::set_has_vertexz() {
  _has_bits_[1] |= 0x00002000u;
}
inline void Electron::clear_has_vertexz() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void Electron::clear_vertexz() {
  vertexz_ = 0;
  clear_has_vertexz();
}
inline double Electron::vertexz() const {
  return vertexz_;
}
inline void Electron::set_vertexz(double value) {
  set_has_vertexz();
  vertexz_ = value;
}

// optional int32 PassID = 48 [default = 0];
inline bool Electron::has_passid() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void Electron::set_has_passid() {
  _has_bits_[1] |= 0x00004000u;
}
inline void Electron::clear_has_passid() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void Electron::clear_passid() {
  passid_ = 0;
  clear_has_passid();
}
inline ::google::protobuf::int32 Electron::passid() const {
  return passid_;
}
inline void Electron::set_passid(::google::protobuf::int32 value) {
  set_has_passid();
  passid_ = value;
}

// optional double PfChargedHadronIso = 49 [default = 0];
inline bool Electron::has_pfchargedhadroniso() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void Electron::set_has_pfchargedhadroniso() {
  _has_bits_[1] |= 0x00008000u;
}
inline void Electron::clear_has_pfchargedhadroniso() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void Electron::clear_pfchargedhadroniso() {
  pfchargedhadroniso_ = 0;
  clear_has_pfchargedhadroniso();
}
inline double Electron::pfchargedhadroniso() const {
  return pfchargedhadroniso_;
}
inline void Electron::set_pfchargedhadroniso(double value) {
  set_has_pfchargedhadroniso();
  pfchargedhadroniso_ = value;
}

// optional double PfNeutralHadronIso = 50 [default = 0];
inline bool Electron::has_pfneutralhadroniso() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void Electron::set_has_pfneutralhadroniso() {
  _has_bits_[1] |= 0x00010000u;
}
inline void Electron::clear_has_pfneutralhadroniso() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void Electron::clear_pfneutralhadroniso() {
  pfneutralhadroniso_ = 0;
  clear_has_pfneutralhadroniso();
}
inline double Electron::pfneutralhadroniso() const {
  return pfneutralhadroniso_;
}
inline void Electron::set_pfneutralhadroniso(double value) {
  set_has_pfneutralhadroniso();
  pfneutralhadroniso_ = value;
}

// optional double PFGammaIso = 51 [default = 0];
inline bool Electron::has_pfgammaiso() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void Electron::set_has_pfgammaiso() {
  _has_bits_[1] |= 0x00020000u;
}
inline void Electron::clear_has_pfgammaiso() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void Electron::clear_pfgammaiso() {
  pfgammaiso_ = 0;
  clear_has_pfgammaiso();
}
inline double Electron::pfgammaiso() const {
  return pfgammaiso_;
}
inline void Electron::set_pfgammaiso(double value) {
  set_has_pfgammaiso();
  pfgammaiso_ = value;
}

// -------------------------------------------------------------------

// Muon

// optional double Energy = 1 [default = 0];
inline bool Muon::has_energy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Muon::set_has_energy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Muon::clear_has_energy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Muon::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline double Muon::energy() const {
  return energy_;
}
inline void Muon::set_energy(double value) {
  set_has_energy();
  energy_ = value;
}

// optional double Px = 2 [default = 0];
inline bool Muon::has_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Muon::set_has_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Muon::clear_has_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Muon::clear_px() {
  px_ = 0;
  clear_has_px();
}
inline double Muon::px() const {
  return px_;
}
inline void Muon::set_px(double value) {
  set_has_px();
  px_ = value;
}

// optional double Py = 3 [default = 0];
inline bool Muon::has_py() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Muon::set_has_py() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Muon::clear_has_py() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Muon::clear_py() {
  py_ = 0;
  clear_has_py();
}
inline double Muon::py() const {
  return py_;
}
inline void Muon::set_py(double value) {
  set_has_py();
  py_ = value;
}

// optional double Pz = 4 [default = 0];
inline bool Muon::has_pz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Muon::set_has_pz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Muon::clear_has_pz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Muon::clear_pz() {
  pz_ = 0;
  clear_has_pz();
}
inline double Muon::pz() const {
  return pz_;
}
inline void Muon::set_pz(double value) {
  set_has_pz();
  pz_ = value;
}

// optional int32 Charge = 5 [default = 0];
inline bool Muon::has_charge() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Muon::set_has_charge() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Muon::clear_has_charge() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Muon::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline ::google::protobuf::int32 Muon::charge() const {
  return charge_;
}
inline void Muon::set_charge(::google::protobuf::int32 value) {
  set_has_charge();
  charge_ = value;
}

// optional double Mass = 6 [default = 0];
inline bool Muon::has_mass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Muon::set_has_mass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Muon::clear_has_mass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Muon::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double Muon::mass() const {
  return mass_;
}
inline void Muon::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// optional double TrkIso03 = 7 [default = 0];
inline bool Muon::has_trkiso03() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Muon::set_has_trkiso03() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Muon::clear_has_trkiso03() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Muon::clear_trkiso03() {
  trkiso03_ = 0;
  clear_has_trkiso03();
}
inline double Muon::trkiso03() const {
  return trkiso03_;
}
inline void Muon::set_trkiso03(double value) {
  set_has_trkiso03();
  trkiso03_ = value;
}

// optional double EcalIso03 = 8 [default = 0];
inline bool Muon::has_ecaliso03() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Muon::set_has_ecaliso03() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Muon::clear_has_ecaliso03() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Muon::clear_ecaliso03() {
  ecaliso03_ = 0;
  clear_has_ecaliso03();
}
inline double Muon::ecaliso03() const {
  return ecaliso03_;
}
inline void Muon::set_ecaliso03(double value) {
  set_has_ecaliso03();
  ecaliso03_ = value;
}

// optional double HcalIso03 = 9 [default = 0];
inline bool Muon::has_hcaliso03() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Muon::set_has_hcaliso03() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Muon::clear_has_hcaliso03() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Muon::clear_hcaliso03() {
  hcaliso03_ = 0;
  clear_has_hcaliso03();
}
inline double Muon::hcaliso03() const {
  return hcaliso03_;
}
inline void Muon::set_hcaliso03(double value) {
  set_has_hcaliso03();
  hcaliso03_ = value;
}

// optional int32 isGoodGlobalMuon = 10 [default = 0];
inline bool Muon::has_isgoodglobalmuon() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Muon::set_has_isgoodglobalmuon() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Muon::clear_has_isgoodglobalmuon() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Muon::clear_isgoodglobalmuon() {
  isgoodglobalmuon_ = 0;
  clear_has_isgoodglobalmuon();
}
inline ::google::protobuf::int32 Muon::isgoodglobalmuon() const {
  return isgoodglobalmuon_;
}
inline void Muon::set_isgoodglobalmuon(::google::protobuf::int32 value) {
  set_has_isgoodglobalmuon();
  isgoodglobalmuon_ = value;
}

// optional double PfChargedHadronIso = 11 [default = 0];
inline bool Muon::has_pfchargedhadroniso() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Muon::set_has_pfchargedhadroniso() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Muon::clear_has_pfchargedhadroniso() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Muon::clear_pfchargedhadroniso() {
  pfchargedhadroniso_ = 0;
  clear_has_pfchargedhadroniso();
}
inline double Muon::pfchargedhadroniso() const {
  return pfchargedhadroniso_;
}
inline void Muon::set_pfchargedhadroniso(double value) {
  set_has_pfchargedhadroniso();
  pfchargedhadroniso_ = value;
}

// optional double PfNeutralHadronIso = 12 [default = 0];
inline bool Muon::has_pfneutralhadroniso() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Muon::set_has_pfneutralhadroniso() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Muon::clear_has_pfneutralhadroniso() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Muon::clear_pfneutralhadroniso() {
  pfneutralhadroniso_ = 0;
  clear_has_pfneutralhadroniso();
}
inline double Muon::pfneutralhadroniso() const {
  return pfneutralhadroniso_;
}
inline void Muon::set_pfneutralhadroniso(double value) {
  set_has_pfneutralhadroniso();
  pfneutralhadroniso_ = value;
}

// optional double PFGammaIso = 13 [default = 0];
inline bool Muon::has_pfgammaiso() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Muon::set_has_pfgammaiso() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Muon::clear_has_pfgammaiso() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Muon::clear_pfgammaiso() {
  pfgammaiso_ = 0;
  clear_has_pfgammaiso();
}
inline double Muon::pfgammaiso() const {
  return pfgammaiso_;
}
inline void Muon::set_pfgammaiso(double value) {
  set_has_pfgammaiso();
  pfgammaiso_ = value;
}

// optional double Eta = 14 [default = 0];
inline bool Muon::has_eta() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Muon::set_has_eta() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Muon::clear_has_eta() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Muon::clear_eta() {
  eta_ = 0;
  clear_has_eta();
}
inline double Muon::eta() const {
  return eta_;
}
inline void Muon::set_eta(double value) {
  set_has_eta();
  eta_ = value;
}

// optional double Phi = 15 [default = 0];
inline bool Muon::has_phi() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Muon::set_has_phi() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Muon::clear_has_phi() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Muon::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double Muon::phi() const {
  return phi_;
}
inline void Muon::set_phi(double value) {
  set_has_phi();
  phi_ = value;
}

// optional double Pt = 16 [default = 0];
inline bool Muon::has_pt() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Muon::set_has_pt() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Muon::clear_has_pt() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Muon::clear_pt() {
  pt_ = 0;
  clear_has_pt();
}
inline double Muon::pt() const {
  return pt_;
}
inline void Muon::set_pt(double value) {
  set_has_pt();
  pt_ = value;
}

// optional double P = 17 [default = 0];
inline bool Muon::has_p() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Muon::set_has_p() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Muon::clear_has_p() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Muon::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline double Muon::p() const {
  return p_;
}
inline void Muon::set_p(double value) {
  set_has_p();
  p_ = value;
}

// optional int32 TrkHits = 18 [default = 0];
inline bool Muon::has_trkhits() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Muon::set_has_trkhits() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Muon::clear_has_trkhits() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Muon::clear_trkhits() {
  trkhits_ = 0;
  clear_has_trkhits();
}
inline ::google::protobuf::int32 Muon::trkhits() const {
  return trkhits_;
}
inline void Muon::set_trkhits(::google::protobuf::int32 value) {
  set_has_trkhits();
  trkhits_ = value;
}

// optional double TrkD0 = 19 [default = 0];
inline bool Muon::has_trkd0() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Muon::set_has_trkd0() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Muon::clear_has_trkd0() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Muon::clear_trkd0() {
  trkd0_ = 0;
  clear_has_trkd0();
}
inline double Muon::trkd0() const {
  return trkd0_;
}
inline void Muon::set_trkd0(double value) {
  set_has_trkd0();
  trkd0_ = value;
}

// optional double TrkD0Error = 20 [default = 0];
inline bool Muon::has_trkd0error() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Muon::set_has_trkd0error() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Muon::clear_has_trkd0error() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Muon::clear_trkd0error() {
  trkd0error_ = 0;
  clear_has_trkd0error();
}
inline double Muon::trkd0error() const {
  return trkd0error_;
}
inline void Muon::set_trkd0error(double value) {
  set_has_trkd0error();
  trkd0error_ = value;
}

// optional double TrkDz = 21 [default = 0];
inline bool Muon::has_trkdz() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Muon::set_has_trkdz() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Muon::clear_has_trkdz() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Muon::clear_trkdz() {
  trkdz_ = 0;
  clear_has_trkdz();
}
inline double Muon::trkdz() const {
  return trkdz_;
}
inline void Muon::set_trkdz(double value) {
  set_has_trkdz();
  trkdz_ = value;
}

// optional double TrkDzError = 22 [default = 0];
inline bool Muon::has_trkdzerror() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Muon::set_has_trkdzerror() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Muon::clear_has_trkdzerror() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Muon::clear_trkdzerror() {
  trkdzerror_ = 0;
  clear_has_trkdzerror();
}
inline double Muon::trkdzerror() const {
  return trkdzerror_;
}
inline void Muon::set_trkdzerror(double value) {
  set_has_trkdzerror();
  trkdzerror_ = value;
}

// optional double GlobalChi2 = 23 [default = 0];
inline bool Muon::has_globalchi2() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Muon::set_has_globalchi2() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Muon::clear_has_globalchi2() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Muon::clear_globalchi2() {
  globalchi2_ = 0;
  clear_has_globalchi2();
}
inline double Muon::globalchi2() const {
  return globalchi2_;
}
inline void Muon::set_globalchi2(double value) {
  set_has_globalchi2();
  globalchi2_ = value;
}

// optional double TrkIso = 24 [default = 0];
inline bool Muon::has_trkiso() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Muon::set_has_trkiso() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Muon::clear_has_trkiso() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Muon::clear_trkiso() {
  trkiso_ = 0;
  clear_has_trkiso();
}
inline double Muon::trkiso() const {
  return trkiso_;
}
inline void Muon::set_trkiso(double value) {
  set_has_trkiso();
  trkiso_ = value;
}

// optional double EcalIso = 25 [default = 0];
inline bool Muon::has_ecaliso() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Muon::set_has_ecaliso() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Muon::clear_has_ecaliso() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Muon::clear_ecaliso() {
  ecaliso_ = 0;
  clear_has_ecaliso();
}
inline double Muon::ecaliso() const {
  return ecaliso_;
}
inline void Muon::set_ecaliso(double value) {
  set_has_ecaliso();
  ecaliso_ = value;
}

// optional double HcalIso = 26 [default = 0];
inline bool Muon::has_hcaliso() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Muon::set_has_hcaliso() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Muon::clear_has_hcaliso() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Muon::clear_hcaliso() {
  hcaliso_ = 0;
  clear_has_hcaliso();
}
inline double Muon::hcaliso() const {
  return hcaliso_;
}
inline void Muon::set_hcaliso(double value) {
  set_has_hcaliso();
  hcaliso_ = value;
}

// optional double HOIso = 27 [default = 0];
inline bool Muon::has_hoiso() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Muon::set_has_hoiso() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Muon::clear_has_hoiso() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Muon::clear_hoiso() {
  hoiso_ = 0;
  clear_has_hoiso();
}
inline double Muon::hoiso() const {
  return hoiso_;
}
inline void Muon::set_hoiso(double value) {
  set_has_hoiso();
  hoiso_ = value;
}

// optional int32 VtxIndex = 28 [default = 0];
inline bool Muon::has_vtxindex() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Muon::set_has_vtxindex() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Muon::clear_has_vtxindex() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Muon::clear_vtxindex() {
  vtxindex_ = 0;
  clear_has_vtxindex();
}
inline ::google::protobuf::int32 Muon::vtxindex() const {
  return vtxindex_;
}
inline void Muon::set_vtxindex(::google::protobuf::int32 value) {
  set_has_vtxindex();
  vtxindex_ = value;
}

// optional double VtxDistXY = 29 [default = 0];
inline bool Muon::has_vtxdistxy() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Muon::set_has_vtxdistxy() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Muon::clear_has_vtxdistxy() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Muon::clear_vtxdistxy() {
  vtxdistxy_ = 0;
  clear_has_vtxdistxy();
}
inline double Muon::vtxdistxy() const {
  return vtxdistxy_;
}
inline void Muon::set_vtxdistxy(double value) {
  set_has_vtxdistxy();
  vtxdistxy_ = value;
}

// optional double VtxDistZ = 30 [default = 0];
inline bool Muon::has_vtxdistz() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Muon::set_has_vtxdistz() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Muon::clear_has_vtxdistz() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Muon::clear_vtxdistz() {
  vtxdistz_ = 0;
  clear_has_vtxdistz();
}
inline double Muon::vtxdistz() const {
  return vtxdistz_;
}
inline void Muon::set_vtxdistz(double value) {
  set_has_vtxdistz();
  vtxdistz_ = value;
}

// optional double CocktailEta = 31 [default = 0];
inline bool Muon::has_cocktaileta() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Muon::set_has_cocktaileta() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Muon::clear_has_cocktaileta() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Muon::clear_cocktaileta() {
  cocktaileta_ = 0;
  clear_has_cocktaileta();
}
inline double Muon::cocktaileta() const {
  return cocktaileta_;
}
inline void Muon::set_cocktaileta(double value) {
  set_has_cocktaileta();
  cocktaileta_ = value;
}

// optional double CocktailPhi = 32 [default = 0];
inline bool Muon::has_cocktailphi() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Muon::set_has_cocktailphi() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Muon::clear_has_cocktailphi() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Muon::clear_cocktailphi() {
  cocktailphi_ = 0;
  clear_has_cocktailphi();
}
inline double Muon::cocktailphi() const {
  return cocktailphi_;
}
inline void Muon::set_cocktailphi(double value) {
  set_has_cocktailphi();
  cocktailphi_ = value;
}

// optional double CocktailPt = 33 [default = 0];
inline bool Muon::has_cocktailpt() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Muon::set_has_cocktailpt() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Muon::clear_has_cocktailpt() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Muon::clear_cocktailpt() {
  cocktailpt_ = 0;
  clear_has_cocktailpt();
}
inline double Muon::cocktailpt() const {
  return cocktailpt_;
}
inline void Muon::set_cocktailpt(double value) {
  set_has_cocktailpt();
  cocktailpt_ = value;
}

// optional double CocktailP = 34 [default = 0];
inline bool Muon::has_cocktailp() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Muon::set_has_cocktailp() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Muon::clear_has_cocktailp() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Muon::clear_cocktailp() {
  cocktailp_ = 0;
  clear_has_cocktailp();
}
inline double Muon::cocktailp() const {
  return cocktailp_;
}
inline void Muon::set_cocktailp(double value) {
  set_has_cocktailp();
  cocktailp_ = value;
}

// optional int32 CocktailCharge = 35 [default = 0];
inline bool Muon::has_cocktailcharge() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Muon::set_has_cocktailcharge() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Muon::clear_has_cocktailcharge() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Muon::clear_cocktailcharge() {
  cocktailcharge_ = 0;
  clear_has_cocktailcharge();
}
inline ::google::protobuf::int32 Muon::cocktailcharge() const {
  return cocktailcharge_;
}
inline void Muon::set_cocktailcharge(::google::protobuf::int32 value) {
  set_has_cocktailcharge();
  cocktailcharge_ = value;
}

// optional int32 CocktailTrkHits = 36 [default = 0];
inline bool Muon::has_cocktailtrkhits() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Muon::set_has_cocktailtrkhits() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Muon::clear_has_cocktailtrkhits() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Muon::clear_cocktailtrkhits() {
  cocktailtrkhits_ = 0;
  clear_has_cocktailtrkhits();
}
inline ::google::protobuf::int32 Muon::cocktailtrkhits() const {
  return cocktailtrkhits_;
}
inline void Muon::set_cocktailtrkhits(::google::protobuf::int32 value) {
  set_has_cocktailtrkhits();
  cocktailtrkhits_ = value;
}

// optional double CocktailTrkD0 = 37 [default = 0];
inline bool Muon::has_cocktailtrkd0() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Muon::set_has_cocktailtrkd0() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Muon::clear_has_cocktailtrkd0() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Muon::clear_cocktailtrkd0() {
  cocktailtrkd0_ = 0;
  clear_has_cocktailtrkd0();
}
inline double Muon::cocktailtrkd0() const {
  return cocktailtrkd0_;
}
inline void Muon::set_cocktailtrkd0(double value) {
  set_has_cocktailtrkd0();
  cocktailtrkd0_ = value;
}

// optional double CocktailTrkD0Error = 38 [default = 0];
inline bool Muon::has_cocktailtrkd0error() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Muon::set_has_cocktailtrkd0error() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Muon::clear_has_cocktailtrkd0error() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Muon::clear_cocktailtrkd0error() {
  cocktailtrkd0error_ = 0;
  clear_has_cocktailtrkd0error();
}
inline double Muon::cocktailtrkd0error() const {
  return cocktailtrkd0error_;
}
inline void Muon::set_cocktailtrkd0error(double value) {
  set_has_cocktailtrkd0error();
  cocktailtrkd0error_ = value;
}

// optional double CocktailTrkDz = 39 [default = 0];
inline bool Muon::has_cocktailtrkdz() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Muon::set_has_cocktailtrkdz() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Muon::clear_has_cocktailtrkdz() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Muon::clear_cocktailtrkdz() {
  cocktailtrkdz_ = 0;
  clear_has_cocktailtrkdz();
}
inline double Muon::cocktailtrkdz() const {
  return cocktailtrkdz_;
}
inline void Muon::set_cocktailtrkdz(double value) {
  set_has_cocktailtrkdz();
  cocktailtrkdz_ = value;
}

// optional double CocktailTrkDzError = 40 [default = 0];
inline bool Muon::has_cocktailtrkdzerror() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Muon::set_has_cocktailtrkdzerror() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Muon::clear_has_cocktailtrkdzerror() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Muon::clear_cocktailtrkdzerror() {
  cocktailtrkdzerror_ = 0;
  clear_has_cocktailtrkdzerror();
}
inline double Muon::cocktailtrkdzerror() const {
  return cocktailtrkdzerror_;
}
inline void Muon::set_cocktailtrkdzerror(double value) {
  set_has_cocktailtrkdzerror();
  cocktailtrkdzerror_ = value;
}

// optional double CocktailGlobalChi2 = 41 [default = 0];
inline bool Muon::has_cocktailglobalchi2() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Muon::set_has_cocktailglobalchi2() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Muon::clear_has_cocktailglobalchi2() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Muon::clear_cocktailglobalchi2() {
  cocktailglobalchi2_ = 0;
  clear_has_cocktailglobalchi2();
}
inline double Muon::cocktailglobalchi2() const {
  return cocktailglobalchi2_;
}
inline void Muon::set_cocktailglobalchi2(double value) {
  set_has_cocktailglobalchi2();
  cocktailglobalchi2_ = value;
}

// optional .HEP.Muon.MuonAlgorithm type = 42 [default = ParticleFlow];
inline bool Muon::has_type() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Muon::set_has_type() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Muon::clear_has_type() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Muon::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::HEP::Muon_MuonAlgorithm Muon::type() const {
  return static_cast< ::HEP::Muon_MuonAlgorithm >(type_);
}
inline void Muon::set_type(::HEP::Muon_MuonAlgorithm value) {
  GOOGLE_DCHECK(::HEP::Muon_MuonAlgorithm_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// MET

// optional double Ex = 1 [default = 0];
inline bool MET::has_ex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MET::set_has_ex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MET::clear_has_ex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MET::clear_ex() {
  ex_ = 0;
  clear_has_ex();
}
inline double MET::ex() const {
  return ex_;
}
inline void MET::set_ex(double value) {
  set_has_ex();
  ex_ = value;
}

// optional double Ey = 2 [default = 0];
inline bool MET::has_ey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MET::set_has_ey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MET::clear_has_ey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MET::clear_ey() {
  ey_ = 0;
  clear_has_ey();
}
inline double MET::ey() const {
  return ey_;
}
inline void MET::set_ey(double value) {
  set_has_ey();
  ey_ = value;
}

// optional double ET = 3 [default = 0];
inline bool MET::has_et() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MET::set_has_et() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MET::clear_has_et() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MET::clear_et() {
  et_ = 0;
  clear_has_et();
}
inline double MET::et() const {
  return et_;
}
inline void MET::set_et(double value) {
  set_has_et();
  et_ = value;
}

// optional double Phi = 4 [default = 0];
inline bool MET::has_phi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MET::set_has_phi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MET::clear_has_phi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MET::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double MET::phi() const {
  return phi_;
}
inline void MET::set_phi(double value) {
  set_has_phi();
  phi_ = value;
}

// optional double SumET = 5 [default = 0];
inline bool MET::has_sumet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MET::set_has_sumet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MET::clear_has_sumet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MET::clear_sumet() {
  sumet_ = 0;
  clear_has_sumet();
}
inline double MET::sumet() const {
  return sumet_;
}
inline void MET::set_sumet(double value) {
  set_has_sumet();
  sumet_ = value;
}

// optional double Significance = 6 [default = 0];
inline bool MET::has_significance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MET::set_has_significance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MET::clear_has_significance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MET::clear_significance() {
  significance_ = 0;
  clear_has_significance();
}
inline double MET::significance() const {
  return significance_;
}
inline void MET::set_significance(double value) {
  set_has_significance();
  significance_ = value;
}

// optional double ETUncorr = 7 [default = 0];
inline bool MET::has_etuncorr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MET::set_has_etuncorr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MET::clear_has_etuncorr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MET::clear_etuncorr() {
  etuncorr_ = 0;
  clear_has_etuncorr();
}
inline double MET::etuncorr() const {
  return etuncorr_;
}
inline void MET::set_etuncorr(double value) {
  set_has_etuncorr();
  etuncorr_ = value;
}

// optional double PhiUncorr = 8 [default = 0];
inline bool MET::has_phiuncorr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MET::set_has_phiuncorr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MET::clear_has_phiuncorr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MET::clear_phiuncorr() {
  phiuncorr_ = 0;
  clear_has_phiuncorr();
}
inline double MET::phiuncorr() const {
  return phiuncorr_;
}
inline void MET::set_phiuncorr(double value) {
  set_has_phiuncorr();
  phiuncorr_ = value;
}

// optional double SumETUncorr = 9 [default = 0];
inline bool MET::has_sumetuncorr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MET::set_has_sumetuncorr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MET::clear_has_sumetuncorr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MET::clear_sumetuncorr() {
  sumetuncorr_ = 0;
  clear_has_sumetuncorr();
}
inline double MET::sumetuncorr() const {
  return sumetuncorr_;
}
inline void MET::set_sumetuncorr(double value) {
  set_has_sumetuncorr();
  sumetuncorr_ = value;
}

// optional .HEP.MET.METAlgorithm type = 10 [default = ParticleFlow];
inline bool MET::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MET::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MET::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MET::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::HEP::MET_METAlgorithm MET::type() const {
  return static_cast< ::HEP::MET_METAlgorithm >(type_);
}
inline void MET::set_type(::HEP::MET_METAlgorithm value) {
  GOOGLE_DCHECK(::HEP::MET_METAlgorithm_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// Vertex

// optional double X = 1 [default = 0];
inline bool Vertex::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vertex::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vertex::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vertex::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vertex::x() const {
  return x_;
}
inline void Vertex::set_x(double value) {
  set_has_x();
  x_ = value;
}

// optional double Y = 2 [default = 0];
inline bool Vertex::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vertex::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vertex::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vertex::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vertex::y() const {
  return y_;
}
inline void Vertex::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double Z = 3 [default = 0];
inline bool Vertex::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vertex::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vertex::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vertex::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vertex::z() const {
  return z_;
}
inline void Vertex::set_z(double value) {
  set_has_z();
  z_ = value;
}

// optional double XErr = 4 [default = 0];
inline bool Vertex::has_xerr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vertex::set_has_xerr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vertex::clear_has_xerr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vertex::clear_xerr() {
  xerr_ = 0;
  clear_has_xerr();
}
inline double Vertex::xerr() const {
  return xerr_;
}
inline void Vertex::set_xerr(double value) {
  set_has_xerr();
  xerr_ = value;
}

// optional double YErr = 5 [default = 0];
inline bool Vertex::has_yerr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vertex::set_has_yerr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vertex::clear_has_yerr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vertex::clear_yerr() {
  yerr_ = 0;
  clear_has_yerr();
}
inline double Vertex::yerr() const {
  return yerr_;
}
inline void Vertex::set_yerr(double value) {
  set_has_yerr();
  yerr_ = value;
}

// optional double ZErr = 6 [default = 0];
inline bool Vertex::has_zerr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Vertex::set_has_zerr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Vertex::clear_has_zerr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Vertex::clear_zerr() {
  zerr_ = 0;
  clear_has_zerr();
}
inline double Vertex::zerr() const {
  return zerr_;
}
inline void Vertex::set_zerr(double value) {
  set_has_zerr();
  zerr_ = value;
}

// optional double Rho = 7 [default = 0];
inline bool Vertex::has_rho() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Vertex::set_has_rho() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Vertex::clear_has_rho() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Vertex::clear_rho() {
  rho_ = 0;
  clear_has_rho();
}
inline double Vertex::rho() const {
  return rho_;
}
inline void Vertex::set_rho(double value) {
  set_has_rho();
  rho_ = value;
}

// optional double Chi2 = 8 [default = 0];
inline bool Vertex::has_chi2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Vertex::set_has_chi2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Vertex::clear_has_chi2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Vertex::clear_chi2() {
  chi2_ = 0;
  clear_has_chi2();
}
inline double Vertex::chi2() const {
  return chi2_;
}
inline void Vertex::set_chi2(double value) {
  set_has_chi2();
  chi2_ = value;
}

// optional double NDF = 9 [default = 0];
inline bool Vertex::has_ndf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Vertex::set_has_ndf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Vertex::clear_has_ndf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Vertex::clear_ndf() {
  ndf_ = 0;
  clear_has_ndf();
}
inline double Vertex::ndf() const {
  return ndf_;
}
inline void Vertex::set_ndf(double value) {
  set_has_ndf();
  ndf_ = value;
}

// optional int32 NTracks = 10 [default = 0];
inline bool Vertex::has_ntracks() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Vertex::set_has_ntracks() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Vertex::clear_has_ntracks() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Vertex::clear_ntracks() {
  ntracks_ = 0;
  clear_has_ntracks();
}
inline ::google::protobuf::int32 Vertex::ntracks() const {
  return ntracks_;
}
inline void Vertex::set_ntracks(::google::protobuf::int32 value) {
  set_has_ntracks();
  ntracks_ = value;
}

// optional int32 NTracksW05 = 11 [default = 0];
inline bool Vertex::has_ntracksw05() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Vertex::set_has_ntracksw05() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Vertex::clear_has_ntracksw05() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Vertex::clear_ntracksw05() {
  ntracksw05_ = 0;
  clear_has_ntracksw05();
}
inline ::google::protobuf::int32 Vertex::ntracksw05() const {
  return ntracksw05_;
}
inline void Vertex::set_ntracksw05(::google::protobuf::int32 value) {
  set_has_ntracksw05();
  ntracksw05_ = value;
}

// optional int32 IsFake = 12 [default = 0];
inline bool Vertex::has_isfake() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Vertex::set_has_isfake() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Vertex::clear_has_isfake() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Vertex::clear_isfake() {
  isfake_ = 0;
  clear_has_isfake();
}
inline ::google::protobuf::int32 Vertex::isfake() const {
  return isfake_;
}
inline void Vertex::set_isfake(::google::protobuf::int32 value) {
  set_has_isfake();
  isfake_ = value;
}

// -------------------------------------------------------------------

// BeamSpot

// optional double WidthX = 1 [default = 0];
inline bool BeamSpot::has_widthx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeamSpot::set_has_widthx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BeamSpot::clear_has_widthx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BeamSpot::clear_widthx() {
  widthx_ = 0;
  clear_has_widthx();
}
inline double BeamSpot::widthx() const {
  return widthx_;
}
inline void BeamSpot::set_widthx(double value) {
  set_has_widthx();
  widthx_ = value;
}

// optional double WidthXError = 2 [default = 0];
inline bool BeamSpot::has_widthxerror() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BeamSpot::set_has_widthxerror() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BeamSpot::clear_has_widthxerror() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BeamSpot::clear_widthxerror() {
  widthxerror_ = 0;
  clear_has_widthxerror();
}
inline double BeamSpot::widthxerror() const {
  return widthxerror_;
}
inline void BeamSpot::set_widthxerror(double value) {
  set_has_widthxerror();
  widthxerror_ = value;
}

// optional double WidthY = 3 [default = 0];
inline bool BeamSpot::has_widthy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BeamSpot::set_has_widthy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BeamSpot::clear_has_widthy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BeamSpot::clear_widthy() {
  widthy_ = 0;
  clear_has_widthy();
}
inline double BeamSpot::widthy() const {
  return widthy_;
}
inline void BeamSpot::set_widthy(double value) {
  set_has_widthy();
  widthy_ = value;
}

// optional double WidthYError = 4 [default = 0];
inline bool BeamSpot::has_widthyerror() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BeamSpot::set_has_widthyerror() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BeamSpot::clear_has_widthyerror() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BeamSpot::clear_widthyerror() {
  widthyerror_ = 0;
  clear_has_widthyerror();
}
inline double BeamSpot::widthyerror() const {
  return widthyerror_;
}
inline void BeamSpot::set_widthyerror(double value) {
  set_has_widthyerror();
  widthyerror_ = value;
}

// optional double X0 = 5 [default = 0];
inline bool BeamSpot::has_x0() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BeamSpot::set_has_x0() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BeamSpot::clear_has_x0() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BeamSpot::clear_x0() {
  x0_ = 0;
  clear_has_x0();
}
inline double BeamSpot::x0() const {
  return x0_;
}
inline void BeamSpot::set_x0(double value) {
  set_has_x0();
  x0_ = value;
}

// optional double X0Error = 6 [default = 0];
inline bool BeamSpot::has_x0error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BeamSpot::set_has_x0error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BeamSpot::clear_has_x0error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BeamSpot::clear_x0error() {
  x0error_ = 0;
  clear_has_x0error();
}
inline double BeamSpot::x0error() const {
  return x0error_;
}
inline void BeamSpot::set_x0error(double value) {
  set_has_x0error();
  x0error_ = value;
}

// optional double Y0 = 7 [default = 0];
inline bool BeamSpot::has_y0() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BeamSpot::set_has_y0() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BeamSpot::clear_has_y0() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BeamSpot::clear_y0() {
  y0_ = 0;
  clear_has_y0();
}
inline double BeamSpot::y0() const {
  return y0_;
}
inline void BeamSpot::set_y0(double value) {
  set_has_y0();
  y0_ = value;
}

// optional double Y0Error = 8 [default = 0];
inline bool BeamSpot::has_y0error() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BeamSpot::set_has_y0error() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BeamSpot::clear_has_y0error() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BeamSpot::clear_y0error() {
  y0error_ = 0;
  clear_has_y0error();
}
inline double BeamSpot::y0error() const {
  return y0error_;
}
inline void BeamSpot::set_y0error(double value) {
  set_has_y0error();
  y0error_ = value;
}

// optional double Z0 = 9 [default = 0];
inline bool BeamSpot::has_z0() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BeamSpot::set_has_z0() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BeamSpot::clear_has_z0() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BeamSpot::clear_z0() {
  z0_ = 0;
  clear_has_z0();
}
inline double BeamSpot::z0() const {
  return z0_;
}
inline void BeamSpot::set_z0(double value) {
  set_has_z0();
  z0_ = value;
}

// optional double Z0Error = 10 [default = 0];
inline bool BeamSpot::has_z0error() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BeamSpot::set_has_z0error() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BeamSpot::clear_has_z0error() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BeamSpot::clear_z0error() {
  z0error_ = 0;
  clear_has_z0error();
}
inline double BeamSpot::z0error() const {
  return z0error_;
}
inline void BeamSpot::set_z0error(double value) {
  set_has_z0error();
  z0error_ = value;
}

// optional double dxdz = 11 [default = 0];
inline bool BeamSpot::has_dxdz() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BeamSpot::set_has_dxdz() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BeamSpot::clear_has_dxdz() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BeamSpot::clear_dxdz() {
  dxdz_ = 0;
  clear_has_dxdz();
}
inline double BeamSpot::dxdz() const {
  return dxdz_;
}
inline void BeamSpot::set_dxdz(double value) {
  set_has_dxdz();
  dxdz_ = value;
}

// optional double dxdzError = 12 [default = 0];
inline bool BeamSpot::has_dxdzerror() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BeamSpot::set_has_dxdzerror() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BeamSpot::clear_has_dxdzerror() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BeamSpot::clear_dxdzerror() {
  dxdzerror_ = 0;
  clear_has_dxdzerror();
}
inline double BeamSpot::dxdzerror() const {
  return dxdzerror_;
}
inline void BeamSpot::set_dxdzerror(double value) {
  set_has_dxdzerror();
  dxdzerror_ = value;
}

// optional double dydz = 13 [default = 0];
inline bool BeamSpot::has_dydz() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BeamSpot::set_has_dydz() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BeamSpot::clear_has_dydz() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BeamSpot::clear_dydz() {
  dydz_ = 0;
  clear_has_dydz();
}
inline double BeamSpot::dydz() const {
  return dydz_;
}
inline void BeamSpot::set_dydz(double value) {
  set_has_dydz();
  dydz_ = value;
}

// optional double dydzError = 14 [default = 0];
inline bool BeamSpot::has_dydzerror() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BeamSpot::set_has_dydzerror() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BeamSpot::clear_has_dydzerror() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BeamSpot::clear_dydzerror() {
  dydzerror_ = 0;
  clear_has_dydzerror();
}
inline double BeamSpot::dydzerror() const {
  return dydzerror_;
}
inline void BeamSpot::set_dydzerror(double value) {
  set_has_dydzerror();
  dydzerror_ = value;
}

// optional double sigmaZ = 15 [default = 0];
inline bool BeamSpot::has_sigmaz() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BeamSpot::set_has_sigmaz() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BeamSpot::clear_has_sigmaz() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BeamSpot::clear_sigmaz() {
  sigmaz_ = 0;
  clear_has_sigmaz();
}
inline double BeamSpot::sigmaz() const {
  return sigmaz_;
}
inline void BeamSpot::set_sigmaz(double value) {
  set_has_sigmaz();
  sigmaz_ = value;
}

// optional double sigmaZError = 16 [default = 0];
inline bool BeamSpot::has_sigmazerror() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BeamSpot::set_has_sigmazerror() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BeamSpot::clear_has_sigmazerror() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BeamSpot::clear_sigmazerror() {
  sigmazerror_ = 0;
  clear_has_sigmazerror();
}
inline double BeamSpot::sigmazerror() const {
  return sigmazerror_;
}
inline void BeamSpot::set_sigmazerror(double value) {
  set_has_sigmazerror();
  sigmazerror_ = value;
}

// -------------------------------------------------------------------

// Trigger

// repeated int32 L1PhysBits = 1;
inline int Trigger::l1physbits_size() const {
  return l1physbits_.size();
}
inline void Trigger::clear_l1physbits() {
  l1physbits_.Clear();
}
inline ::google::protobuf::int32 Trigger::l1physbits(int index) const {
  return l1physbits_.Get(index);
}
inline void Trigger::set_l1physbits(int index, ::google::protobuf::int32 value) {
  l1physbits_.Set(index, value);
}
inline void Trigger::add_l1physbits(::google::protobuf::int32 value) {
  l1physbits_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trigger::l1physbits() const {
  return l1physbits_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trigger::mutable_l1physbits() {
  return &l1physbits_;
}

// repeated int32 L1TechBits = 2;
inline int Trigger::l1techbits_size() const {
  return l1techbits_.size();
}
inline void Trigger::clear_l1techbits() {
  l1techbits_.Clear();
}
inline ::google::protobuf::int32 Trigger::l1techbits(int index) const {
  return l1techbits_.Get(index);
}
inline void Trigger::set_l1techbits(int index, ::google::protobuf::int32 value) {
  l1techbits_.Set(index, value);
}
inline void Trigger::add_l1techbits(::google::protobuf::int32 value) {
  l1techbits_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trigger::l1techbits() const {
  return l1techbits_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trigger::mutable_l1techbits() {
  return &l1techbits_;
}

// repeated int32 HLTBits = 3;
inline int Trigger::hltbits_size() const {
  return hltbits_.size();
}
inline void Trigger::clear_hltbits() {
  hltbits_.Clear();
}
inline ::google::protobuf::int32 Trigger::hltbits(int index) const {
  return hltbits_.Get(index);
}
inline void Trigger::set_hltbits(int index, ::google::protobuf::int32 value) {
  hltbits_.Set(index, value);
}
inline void Trigger::add_hltbits(::google::protobuf::int32 value) {
  hltbits_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trigger::hltbits() const {
  return hltbits_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trigger::mutable_hltbits() {
  return &hltbits_;
}

// repeated int32 HLTResults = 4;
inline int Trigger::hltresults_size() const {
  return hltresults_.size();
}
inline void Trigger::clear_hltresults() {
  hltresults_.Clear();
}
inline ::google::protobuf::int32 Trigger::hltresults(int index) const {
  return hltresults_.Get(index);
}
inline void Trigger::set_hltresults(int index, ::google::protobuf::int32 value) {
  hltresults_.Set(index, value);
}
inline void Trigger::add_hltresults(::google::protobuf::int32 value) {
  hltresults_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trigger::hltresults() const {
  return hltresults_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trigger::mutable_hltresults() {
  return &hltresults_;
}

// repeated int32 HLTResultsOther = 5;
inline int Trigger::hltresultsother_size() const {
  return hltresultsother_.size();
}
inline void Trigger::clear_hltresultsother() {
  hltresultsother_.Clear();
}
inline ::google::protobuf::int32 Trigger::hltresultsother(int index) const {
  return hltresultsother_.Get(index);
}
inline void Trigger::set_hltresultsother(int index, ::google::protobuf::int32 value) {
  hltresultsother_.Set(index, value);
}
inline void Trigger::add_hltresultsother(::google::protobuf::int32 value) {
  hltresultsother_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trigger::hltresultsother() const {
  return hltresultsother_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trigger::mutable_hltresultsother() {
  return &hltresultsother_;
}

// repeated int32 HLTPrescales = 6;
inline int Trigger::hltprescales_size() const {
  return hltprescales_.size();
}
inline void Trigger::clear_hltprescales() {
  hltprescales_.Clear();
}
inline ::google::protobuf::int32 Trigger::hltprescales(int index) const {
  return hltprescales_.Get(index);
}
inline void Trigger::set_hltprescales(int index, ::google::protobuf::int32 value) {
  hltprescales_.Set(index, value);
}
inline void Trigger::add_hltprescales(::google::protobuf::int32 value) {
  hltprescales_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trigger::hltprescales() const {
  return hltprescales_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trigger::mutable_hltprescales() {
  return &hltprescales_;
}

// repeated int32 HLTPrescalesOther = 7;
inline int Trigger::hltprescalesother_size() const {
  return hltprescalesother_.size();
}
inline void Trigger::clear_hltprescalesother() {
  hltprescalesother_.Clear();
}
inline ::google::protobuf::int32 Trigger::hltprescalesother(int index) const {
  return hltprescalesother_.Get(index);
}
inline void Trigger::set_hltprescalesother(int index, ::google::protobuf::int32 value) {
  hltprescalesother_.Set(index, value);
}
inline void Trigger::add_hltprescalesother(::google::protobuf::int32 value) {
  hltprescalesother_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trigger::hltprescalesother() const {
  return hltprescalesother_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trigger::mutable_hltprescalesother() {
  return &hltprescalesother_;
}

// repeated string HLTNames = 8;
inline int Trigger::hltnames_size() const {
  return hltnames_.size();
}
inline void Trigger::clear_hltnames() {
  hltnames_.Clear();
}
inline const ::std::string& Trigger::hltnames(int index) const {
  return hltnames_.Get(index);
}
inline ::std::string* Trigger::mutable_hltnames(int index) {
  return hltnames_.Mutable(index);
}
inline void Trigger::set_hltnames(int index, const ::std::string& value) {
  hltnames_.Mutable(index)->assign(value);
}
inline void Trigger::set_hltnames(int index, const char* value) {
  hltnames_.Mutable(index)->assign(value);
}
inline void Trigger::set_hltnames(int index, const char* value, size_t size) {
  hltnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trigger::add_hltnames() {
  return hltnames_.Add();
}
inline void Trigger::add_hltnames(const ::std::string& value) {
  hltnames_.Add()->assign(value);
}
inline void Trigger::add_hltnames(const char* value) {
  hltnames_.Add()->assign(value);
}
inline void Trigger::add_hltnames(const char* value, size_t size) {
  hltnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Trigger::hltnames() const {
  return hltnames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Trigger::mutable_hltnames() {
  return &hltnames_;
}

// -------------------------------------------------------------------

// Event

// repeated .HEP.Jet goodPatJets = 1;
inline int Event::goodpatjets_size() const {
  return goodpatjets_.size();
}
inline void Event::clear_goodpatjets() {
  goodpatjets_.Clear();
}
inline const ::HEP::Jet& Event::goodpatjets(int index) const {
  return goodpatjets_.Get(index);
}
inline ::HEP::Jet* Event::mutable_goodpatjets(int index) {
  return goodpatjets_.Mutable(index);
}
inline ::HEP::Jet* Event::add_goodpatjets() {
  return goodpatjets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Jet >&
Event::goodpatjets() const {
  return goodpatjets_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Jet >*
Event::mutable_goodpatjets() {
  return &goodpatjets_;
}

// repeated .HEP.Jet goodPatJetsPFlow = 2;
inline int Event::goodpatjetspflow_size() const {
  return goodpatjetspflow_.size();
}
inline void Event::clear_goodpatjetspflow() {
  goodpatjetspflow_.Clear();
}
inline const ::HEP::Jet& Event::goodpatjetspflow(int index) const {
  return goodpatjetspflow_.Get(index);
}
inline ::HEP::Jet* Event::mutable_goodpatjetspflow(int index) {
  return goodpatjetspflow_.Mutable(index);
}
inline ::HEP::Jet* Event::add_goodpatjetspflow() {
  return goodpatjetspflow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Jet >&
Event::goodpatjetspflow() const {
  return goodpatjetspflow_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Jet >*
Event::mutable_goodpatjetspflow() {
  return &goodpatjetspflow_;
}

// repeated .HEP.Jet goodPatJetsCA8PF = 3;
inline int Event::goodpatjetsca8pf_size() const {
  return goodpatjetsca8pf_.size();
}
inline void Event::clear_goodpatjetsca8pf() {
  goodpatjetsca8pf_.Clear();
}
inline const ::HEP::Jet& Event::goodpatjetsca8pf(int index) const {
  return goodpatjetsca8pf_.Get(index);
}
inline ::HEP::Jet* Event::mutable_goodpatjetsca8pf(int index) {
  return goodpatjetsca8pf_.Mutable(index);
}
inline ::HEP::Jet* Event::add_goodpatjetsca8pf() {
  return goodpatjetsca8pf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Jet >&
Event::goodpatjetsca8pf() const {
  return goodpatjetsca8pf_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Jet >*
Event::mutable_goodpatjetsca8pf() {
  return &goodpatjetsca8pf_;
}

// repeated .HEP.Electron selectedPatElectrons = 4;
inline int Event::selectedpatelectrons_size() const {
  return selectedpatelectrons_.size();
}
inline void Event::clear_selectedpatelectrons() {
  selectedpatelectrons_.Clear();
}
inline const ::HEP::Electron& Event::selectedpatelectrons(int index) const {
  return selectedpatelectrons_.Get(index);
}
inline ::HEP::Electron* Event::mutable_selectedpatelectrons(int index) {
  return selectedpatelectrons_.Mutable(index);
}
inline ::HEP::Electron* Event::add_selectedpatelectrons() {
  return selectedpatelectrons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Electron >&
Event::selectedpatelectrons() const {
  return selectedpatelectrons_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Electron >*
Event::mutable_selectedpatelectrons() {
  return &selectedpatelectrons_;
}

// repeated .HEP.Electron selectedPatElectronsLoosePFlow = 5;
inline int Event::selectedpatelectronsloosepflow_size() const {
  return selectedpatelectronsloosepflow_.size();
}
inline void Event::clear_selectedpatelectronsloosepflow() {
  selectedpatelectronsloosepflow_.Clear();
}
inline const ::HEP::Electron& Event::selectedpatelectronsloosepflow(int index) const {
  return selectedpatelectronsloosepflow_.Get(index);
}
inline ::HEP::Electron* Event::mutable_selectedpatelectronsloosepflow(int index) {
  return selectedpatelectronsloosepflow_.Mutable(index);
}
inline ::HEP::Electron* Event::add_selectedpatelectronsloosepflow() {
  return selectedpatelectronsloosepflow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Electron >&
Event::selectedpatelectronsloosepflow() const {
  return selectedpatelectronsloosepflow_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Electron >*
Event::mutable_selectedpatelectronsloosepflow() {
  return &selectedpatelectronsloosepflow_;
}

// repeated .HEP.MET patMETs = 6;
inline int Event::patmets_size() const {
  return patmets_.size();
}
inline void Event::clear_patmets() {
  patmets_.Clear();
}
inline const ::HEP::MET& Event::patmets(int index) const {
  return patmets_.Get(index);
}
inline ::HEP::MET* Event::mutable_patmets(int index) {
  return patmets_.Mutable(index);
}
inline ::HEP::MET* Event::add_patmets() {
  return patmets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::MET >&
Event::patmets() const {
  return patmets_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::MET >*
Event::mutable_patmets() {
  return &patmets_;
}

// repeated .HEP.MET patMETsPFlow = 7;
inline int Event::patmetspflow_size() const {
  return patmetspflow_.size();
}
inline void Event::clear_patmetspflow() {
  patmetspflow_.Clear();
}
inline const ::HEP::MET& Event::patmetspflow(int index) const {
  return patmetspflow_.Get(index);
}
inline ::HEP::MET* Event::mutable_patmetspflow(int index) {
  return patmetspflow_.Mutable(index);
}
inline ::HEP::MET* Event::add_patmetspflow() {
  return patmetspflow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::MET >&
Event::patmetspflow() const {
  return patmetspflow_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::MET >*
Event::mutable_patmetspflow() {
  return &patmetspflow_;
}

// repeated .HEP.Muon selectedPatMuons = 8;
inline int Event::selectedpatmuons_size() const {
  return selectedpatmuons_.size();
}
inline void Event::clear_selectedpatmuons() {
  selectedpatmuons_.Clear();
}
inline const ::HEP::Muon& Event::selectedpatmuons(int index) const {
  return selectedpatmuons_.Get(index);
}
inline ::HEP::Muon* Event::mutable_selectedpatmuons(int index) {
  return selectedpatmuons_.Mutable(index);
}
inline ::HEP::Muon* Event::add_selectedpatmuons() {
  return selectedpatmuons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Muon >&
Event::selectedpatmuons() const {
  return selectedpatmuons_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Muon >*
Event::mutable_selectedpatmuons() {
  return &selectedpatmuons_;
}

// repeated .HEP.Muon selectedPatMuonsLoosePFlow = 9;
inline int Event::selectedpatmuonsloosepflow_size() const {
  return selectedpatmuonsloosepflow_.size();
}
inline void Event::clear_selectedpatmuonsloosepflow() {
  selectedpatmuonsloosepflow_.Clear();
}
inline const ::HEP::Muon& Event::selectedpatmuonsloosepflow(int index) const {
  return selectedpatmuonsloosepflow_.Get(index);
}
inline ::HEP::Muon* Event::mutable_selectedpatmuonsloosepflow(int index) {
  return selectedpatmuonsloosepflow_.Mutable(index);
}
inline ::HEP::Muon* Event::add_selectedpatmuonsloosepflow() {
  return selectedpatmuonsloosepflow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Muon >&
Event::selectedpatmuonsloosepflow() const {
  return selectedpatmuonsloosepflow_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Muon >*
Event::mutable_selectedpatmuonsloosepflow() {
  return &selectedpatmuonsloosepflow_;
}

// repeated .HEP.Vertex goodOfflinePrimaryVertices = 10;
inline int Event::goodofflineprimaryvertices_size() const {
  return goodofflineprimaryvertices_.size();
}
inline void Event::clear_goodofflineprimaryvertices() {
  goodofflineprimaryvertices_.Clear();
}
inline const ::HEP::Vertex& Event::goodofflineprimaryvertices(int index) const {
  return goodofflineprimaryvertices_.Get(index);
}
inline ::HEP::Vertex* Event::mutable_goodofflineprimaryvertices(int index) {
  return goodofflineprimaryvertices_.Mutable(index);
}
inline ::HEP::Vertex* Event::add_goodofflineprimaryvertices() {
  return goodofflineprimaryvertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Vertex >&
Event::goodofflineprimaryvertices() const {
  return goodofflineprimaryvertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Vertex >*
Event::mutable_goodofflineprimaryvertices() {
  return &goodofflineprimaryvertices_;
}

// repeated .HEP.BeamSpot beamSpot = 11;
inline int Event::beamspot_size() const {
  return beamspot_.size();
}
inline void Event::clear_beamspot() {
  beamspot_.Clear();
}
inline const ::HEP::BeamSpot& Event::beamspot(int index) const {
  return beamspot_.Get(index);
}
inline ::HEP::BeamSpot* Event::mutable_beamspot(int index) {
  return beamspot_.Mutable(index);
}
inline ::HEP::BeamSpot* Event::add_beamspot() {
  return beamspot_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::BeamSpot >&
Event::beamspot() const {
  return beamspot_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::BeamSpot >*
Event::mutable_beamspot() {
  return &beamspot_;
}

// optional double MagneticField = 12;
inline bool Event::has_magneticfield() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Event::set_has_magneticfield() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Event::clear_has_magneticfield() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Event::clear_magneticfield() {
  magneticfield_ = 0;
  clear_has_magneticfield();
}
inline double Event::magneticfield() const {
  return magneticfield_;
}
inline void Event::set_magneticfield(double value) {
  set_has_magneticfield();
  magneticfield_ = value;
}

// required uint32 Run = 13;
inline bool Event::has_run() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Event::set_has_run() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Event::clear_has_run() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Event::clear_run() {
  run_ = 0u;
  clear_has_run();
}
inline ::google::protobuf::uint32 Event::run() const {
  return run_;
}
inline void Event::set_run(::google::protobuf::uint32 value) {
  set_has_run();
  run_ = value;
}

// required uint32 Number = 14;
inline bool Event::has_number() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Event::set_has_number() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Event::clear_has_number() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Event::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 Event::number() const {
  return number_;
}
inline void Event::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// optional uint32 Bunch = 15;
inline bool Event::has_bunch() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Event::set_has_bunch() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Event::clear_has_bunch() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Event::clear_bunch() {
  bunch_ = 0u;
  clear_has_bunch();
}
inline ::google::protobuf::uint32 Event::bunch() const {
  return bunch_;
}
inline void Event::set_bunch(::google::protobuf::uint32 value) {
  set_has_bunch();
  bunch_ = value;
}

// required uint32 LumiSection = 16;
inline bool Event::has_lumisection() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Event::set_has_lumisection() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Event::clear_has_lumisection() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Event::clear_lumisection() {
  lumisection_ = 0u;
  clear_has_lumisection();
}
inline ::google::protobuf::uint32 Event::lumisection() const {
  return lumisection_;
}
inline void Event::set_lumisection(::google::protobuf::uint32 value) {
  set_has_lumisection();
  lumisection_ = value;
}

// optional uint32 Orbit = 17;
inline bool Event::has_orbit() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Event::set_has_orbit() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Event::clear_has_orbit() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Event::clear_orbit() {
  orbit_ = 0u;
  clear_has_orbit();
}
inline ::google::protobuf::uint32 Event::orbit() const {
  return orbit_;
}
inline void Event::set_orbit(::google::protobuf::uint32 value) {
  set_has_orbit();
  orbit_ = value;
}

// optional double Time = 18;
inline bool Event::has_time() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Event::set_has_time() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Event::clear_has_time() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Event::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double Event::time() const {
  return time_;
}
inline void Event::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional bool isData = 19;
inline bool Event::has_isdata() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Event::set_has_isdata() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Event::clear_has_isdata() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Event::clear_isdata() {
  isdata_ = false;
  clear_has_isdata();
}
inline bool Event::isdata() const {
  return isdata_;
}
inline void Event::set_isdata(bool value) {
  set_has_isdata();
  isdata_ = value;
}

// optional double rho = 20;
inline bool Event::has_rho() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Event::set_has_rho() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Event::clear_has_rho() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Event::clear_rho() {
  rho_ = 0;
  clear_has_rho();
}
inline double Event::rho() const {
  return rho_;
}
inline void Event::set_rho(double value) {
  set_has_rho();
  rho_ = value;
}

// repeated .HEP.Trigger trigger = 21;
inline int Event::trigger_size() const {
  return trigger_.size();
}
inline void Event::clear_trigger() {
  trigger_.Clear();
}
inline const ::HEP::Trigger& Event::trigger(int index) const {
  return trigger_.Get(index);
}
inline ::HEP::Trigger* Event::mutable_trigger(int index) {
  return trigger_.Mutable(index);
}
inline ::HEP::Trigger* Event::add_trigger() {
  return trigger_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Trigger >&
Event::trigger() const {
  return trigger_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Trigger >*
Event::mutable_trigger() {
  return &trigger_;
}

// -------------------------------------------------------------------

// GenEvent

// optional uint32 ProcessID = 1;
inline bool GenEvent::has_processid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenEvent::set_has_processid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenEvent::clear_has_processid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenEvent::clear_processid() {
  processid_ = 0u;
  clear_has_processid();
}
inline ::google::protobuf::uint32 GenEvent::processid() const {
  return processid_;
}
inline void GenEvent::set_processid(::google::protobuf::uint32 value) {
  set_has_processid();
  processid_ = value;
}

// optional double PtHat = 2;
inline bool GenEvent::has_pthat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenEvent::set_has_pthat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenEvent::clear_has_pthat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenEvent::clear_pthat() {
  pthat_ = 0;
  clear_has_pthat();
}
inline double GenEvent::pthat() const {
  return pthat_;
}
inline void GenEvent::set_pthat(double value) {
  set_has_pthat();
  pthat_ = value;
}

// repeated double PDFWeights = 3;
inline int GenEvent::pdfweights_size() const {
  return pdfweights_.size();
}
inline void GenEvent::clear_pdfweights() {
  pdfweights_.Clear();
}
inline double GenEvent::pdfweights(int index) const {
  return pdfweights_.Get(index);
}
inline void GenEvent::set_pdfweights(int index, double value) {
  pdfweights_.Set(index, value);
}
inline void GenEvent::add_pdfweights(double value) {
  pdfweights_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
GenEvent::pdfweights() const {
  return pdfweights_;
}
inline ::google::protobuf::RepeatedField< double >*
GenEvent::mutable_pdfweights() {
  return &pdfweights_;
}

// repeated int32 PileUpInteractions = 4;
inline int GenEvent::pileupinteractions_size() const {
  return pileupinteractions_.size();
}
inline void GenEvent::clear_pileupinteractions() {
  pileupinteractions_.Clear();
}
inline ::google::protobuf::int32 GenEvent::pileupinteractions(int index) const {
  return pileupinteractions_.Get(index);
}
inline void GenEvent::set_pileupinteractions(int index, ::google::protobuf::int32 value) {
  pileupinteractions_.Set(index, value);
}
inline void GenEvent::add_pileupinteractions(::google::protobuf::int32 value) {
  pileupinteractions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GenEvent::pileupinteractions() const {
  return pileupinteractions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GenEvent::mutable_pileupinteractions() {
  return &pileupinteractions_;
}

// repeated int32 PileUpOriginBX = 5;
inline int GenEvent::pileuporiginbx_size() const {
  return pileuporiginbx_.size();
}
inline void GenEvent::clear_pileuporiginbx() {
  pileuporiginbx_.Clear();
}
inline ::google::protobuf::int32 GenEvent::pileuporiginbx(int index) const {
  return pileuporiginbx_.Get(index);
}
inline void GenEvent::set_pileuporiginbx(int index, ::google::protobuf::int32 value) {
  pileuporiginbx_.Set(index, value);
}
inline void GenEvent::add_pileuporiginbx(::google::protobuf::int32 value) {
  pileuporiginbx_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GenEvent::pileuporiginbx() const {
  return pileuporiginbx_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GenEvent::mutable_pileuporiginbx() {
  return &pileuporiginbx_;
}

// repeated double GenMETExTrue = 6;
inline int GenEvent::genmetextrue_size() const {
  return genmetextrue_.size();
}
inline void GenEvent::clear_genmetextrue() {
  genmetextrue_.Clear();
}
inline double GenEvent::genmetextrue(int index) const {
  return genmetextrue_.Get(index);
}
inline void GenEvent::set_genmetextrue(int index, double value) {
  genmetextrue_.Set(index, value);
}
inline void GenEvent::add_genmetextrue(double value) {
  genmetextrue_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
GenEvent::genmetextrue() const {
  return genmetextrue_;
}
inline ::google::protobuf::RepeatedField< double >*
GenEvent::mutable_genmetextrue() {
  return &genmetextrue_;
}

// repeated double GenMETEyTrue = 7;
inline int GenEvent::genmeteytrue_size() const {
  return genmeteytrue_.size();
}
inline void GenEvent::clear_genmeteytrue() {
  genmeteytrue_.Clear();
}
inline double GenEvent::genmeteytrue(int index) const {
  return genmeteytrue_.Get(index);
}
inline void GenEvent::set_genmeteytrue(int index, double value) {
  genmeteytrue_.Set(index, value);
}
inline void GenEvent::add_genmeteytrue(double value) {
  genmeteytrue_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
GenEvent::genmeteytrue() const {
  return genmeteytrue_;
}
inline ::google::protobuf::RepeatedField< double >*
GenEvent::mutable_genmeteytrue() {
  return &genmeteytrue_;
}

// repeated .HEP.GenJet genJets = 8;
inline int GenEvent::genjets_size() const {
  return genjets_.size();
}
inline void GenEvent::clear_genjets() {
  genjets_.Clear();
}
inline const ::HEP::GenJet& GenEvent::genjets(int index) const {
  return genjets_.Get(index);
}
inline ::HEP::GenJet* GenEvent::mutable_genjets(int index) {
  return genjets_.Mutable(index);
}
inline ::HEP::GenJet* GenEvent::add_genjets() {
  return genjets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::GenJet >&
GenEvent::genjets() const {
  return genjets_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::GenJet >*
GenEvent::mutable_genjets() {
  return &genjets_;
}

// repeated .HEP.GenParticle genParticles = 9;
inline int GenEvent::genparticles_size() const {
  return genparticles_.size();
}
inline void GenEvent::clear_genparticles() {
  genparticles_.Clear();
}
inline const ::HEP::GenParticle& GenEvent::genparticles(int index) const {
  return genparticles_.Get(index);
}
inline ::HEP::GenParticle* GenEvent::mutable_genparticles(int index) {
  return genparticles_.Mutable(index);
}
inline ::HEP::GenParticle* GenEvent::add_genparticles() {
  return genparticles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::GenParticle >&
GenEvent::genparticles() const {
  return genparticles_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::GenParticle >*
GenEvent::mutable_genparticles() {
  return &genparticles_;
}

// -------------------------------------------------------------------

// EventCollection

// repeated .HEP.Event event = 1;
inline int EventCollection::event_size() const {
  return event_.size();
}
inline void EventCollection::clear_event() {
  event_.Clear();
}
inline const ::HEP::Event& EventCollection::event(int index) const {
  return event_.Get(index);
}
inline ::HEP::Event* EventCollection::mutable_event(int index) {
  return event_.Mutable(index);
}
inline ::HEP::Event* EventCollection::add_event() {
  return event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Event >&
EventCollection::event() const {
  return event_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Event >*
EventCollection::mutable_event() {
  return &event_;
}

// repeated .HEP.GenEvent genEvent = 2;
inline int EventCollection::genevent_size() const {
  return genevent_.size();
}
inline void EventCollection::clear_genevent() {
  genevent_.Clear();
}
inline const ::HEP::GenEvent& EventCollection::genevent(int index) const {
  return genevent_.Get(index);
}
inline ::HEP::GenEvent* EventCollection::mutable_genevent(int index) {
  return genevent_.Mutable(index);
}
inline ::HEP::GenEvent* EventCollection::add_genevent() {
  return genevent_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::GenEvent >&
EventCollection::genevent() const {
  return genevent_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::GenEvent >*
EventCollection::mutable_genevent() {
  return &genevent_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace HEP

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HEP::Jet_JetAlgorithm>() {
  return ::HEP::Jet_JetAlgorithm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HEP::Electron_ElectronAlgorithm>() {
  return ::HEP::Electron_ElectronAlgorithm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HEP::Muon_MuonAlgorithm>() {
  return ::HEP::Muon_MuonAlgorithm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HEP::MET_METAlgorithm>() {
  return ::HEP::MET_METAlgorithm_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_EventCollection_2eproto__INCLUDED
